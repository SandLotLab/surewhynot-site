<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roguelike | surewhynot.app</title>

  <!-- SEO -->
  <meta name="description" content="Top-down roguelike in the browser with 51 passable levels (0–50). Enemies scale by difficulty. Tracks best moves/time per level locally." />
  <meta name="robots" content="index,follow" />
  <link rel="canonical" href="https://surewhynot.app/roguelike" />
  <meta property="og:title" content="Roguelike | surewhynot.app" />
  <meta property="og:description" content="51 passable levels (0–50). Enemy scaling difficulty. Best moves/time per level saved locally." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://surewhynot.app/roguelike" />

  <!-- Google AdSense -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7167291111213614"
    crossorigin="anonymous"></script>

  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#0b0f14; color:#e6edf3;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    }
    .wrap{ width:min(1020px,96vw); }
    header{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; padding:10px 0; flex-wrap:wrap; }
    .card{
      border:1px solid #1f2630; background:#0f1620; border-radius:14px; padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    canvas{
      width:100%; height:auto; display:block; border-radius:12px; border:1px solid #1f2630; background:#070a0e;
    }
    .hud{
      display:flex; justify-content:space-between; gap:12px; margin-top:8px;
      font-size:12px; opacity:.88; flex-wrap:wrap; align-items:center;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill{
      display:inline-block; padding:6px 10px; border:1px solid #1f2630; border-radius:999px;
      text-decoration:none; color:inherit; opacity:.92;
    }
    .pill:hover{ opacity:1; }
    input{
      background:#0b0f14; color:#e6edf3; border:1px solid #1f2630; border-radius:10px;
      padding:6px 10px; font:inherit; font-size:12px; width:88px;
    }
    .muted{ opacity:.65; }
    .overlay{
      position:absolute; inset:0; display:none; place-items:center;
      background:rgba(0,0,0,.55); border-radius:12px;
    }
    .panel{
      width:min(520px, 92%); border:1px solid #1f2630; background:#0b0f14; border-radius:14px;
      padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.45);
    }
    .h1{ font-weight:700; font-size:14px; }
    .btnrow{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    button{
      cursor:pointer; background:#0f1620; color:#e6edf3; border:1px solid #1f2630; border-radius:12px;
      padding:8px 10px; font:inherit; font-size:12px;
    }
    button:hover{ border-color:#2a3a50; }
  </style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="row">
      <div><b>Roguelike</b> <span id="seedShort" class="muted" style="font-size:12px;"></span></div>
      <span class="muted" style="font-size:12px;">Controls: WASD/Arrows move • R restart level • N next • P prev</span>
    </div>

    <div class="row">
      <label class="muted" for="levelInput">Level</label>
      <input id="levelInput" type="number" min="0" max="50" step="1" value="0" />
      <button id="goBtn">Go</button>
      <button id="resetBestBtn" title="Clears best stats for this level only">Reset Best</button>
    </div>
  </header>

  <div class="card">
    <div style="position:relative;">
      <canvas id="game" width="768" height="512"></canvas>

      <div id="overlay" class="overlay">
        <div class="panel">
          <div class="h1" id="overlayTitle">Level Complete</div>
          <div class="muted" id="overlayBody" style="margin-top:8px; line-height:1.6;"></div>
          <div class="btnrow">
            <button id="nextBtn">Next Level (N)</button>
            <button id="retryBtn">Retry (R)</button>
            <button id="closeBtn">Close</button>
          </div>
        </div>
      </div>
    </div>

    <div class="hud">
      <div class="row">
        <div>Level: <b id="lvlLabel">0</b> <span class="muted" id="tierLabel"></span></div>
        <div>Enemies: <b id="enemyLabel">0</b></div>
        <div>Goal: <span class="muted">reach green</span></div>
      </div>

      <div class="row">
        <div>Moves (run): <b id="movesRun">0</b></div>
        <div>Time (run): <b id="timeRun">0.0s</b></div>
        <div class="muted">Best: <b id="bestLabel">—</b></div>
      </div>

      <div class="row">
        <div>Status: <b id="status">Ready</b></div>
        <div class="muted">Seed: <span id="seedFull"></span></div>
      </div>
    </div>

    <ins class="adsbygoogle"
         style="display:block;margin-top:12px"
         data-ad-client="ca-pub-7167291111213614"
         data-ad-slot="auto"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>
  </div>
</div>

<script>
"use strict";

/* 51 levels (0–50), always passable:
   - Generate dungeon
   - Place player + exit
   - Verify path exists (BFS)
   - Enemies scale by level
   - Best moves/time saved per level in localStorage (per visitor)
*/

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });

const statusEl   = document.getElementById("status");
const seedShort  = document.getElementById("seedShort");
const seedFull   = document.getElementById("seedFull");
const lvlLabel   = document.getElementById("lvlLabel");
const tierLabel  = document.getElementById("tierLabel");
const enemyLabel = document.getElementById("enemyLabel");
const movesRunEl = document.getElementById("movesRun");
const timeRunEl  = document.getElementById("timeRun");
const bestLabel  = document.getElementById("bestLabel");
const levelInput = document.getElementById("levelInput");
const goBtn      = document.getElementById("goBtn");
const resetBestBtn = document.getElementById("resetBestBtn");

const overlay = document.getElementById("overlay");
const overlayTitle = document.getElementById("overlayTitle");
const overlayBody = document.getElementById("overlayBody");
const nextBtn = document.getElementById("nextBtn");
const retryBtn = document.getElementById("retryBtn");
const closeBtn = document.getElementById("closeBtn");

const TILE = 16;
const W = Math.floor(canvas.width / TILE);
const H = Math.floor(canvas.height / TILE);

const WALL = 0, FLOOR = 1;

let level = 0;
let seed, rng;
let map = [];
let player = {x:0,y:0};
let exit = {x:0,y:0};
let enemies = [];
let alive = true;
let won = false;

let moves = 0;
let startMs = 0;
let running = false;

// ---------- RNG ----------
function makeSeed() {
  return "run-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
}
function hash32(str) {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(a) {
  return function() {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function randi(min, maxIncl) {
  return Math.floor(rng() * (maxIncl - min + 1)) + min;
}
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ---------- Difficulty ----------
function tierForLevel(lv){
  if (lv <= 9) return "Easiest (0–9)";
  if (lv <= 19) return "Easy (10–19)";
  if (lv <= 29) return "Medium (20–29)";
  if (lv <= 39) return "Hard (30–39)";
  if (lv <= 49) return "Insane (40–49)";
  return "You will not survive (50)";
}

function paramsForLevel(lv){
  // Always passable. Difficulty comes from enemies + chase speed + path length.
  const t = (lv <= 9) ? 0 : (lv <= 19) ? 1 : (lv <= 29) ? 2 : (lv <= 39) ? 3 : (lv <= 49) ? 4 : 5;

  // Enemy count scaling (kept sane for a static canvas)
  const baseEnemies = [1, 2, 3, 5, 7, 10][t];
  const extra = Math.floor(lv / 10); // small ramp within each tier
  const enemyCount = Math.min(baseEnemies + extra, 14);

  // Enemy steps per player move (harder tiers move more)
  const enemySteps = [1,1,1,2,2,3][t];

  // Minimum required path length player->exit
  const minPath = [10, 14, 18, 22, 26, 30][t];

  // Map density knobs
  const roomAttempts = 20 + lv;      // more attempts -> more rooms
  const maxRooms = clamp(10 + Math.floor(lv * 0.35), 12, 28);

  return { t, enemyCount, enemySteps, minPath, roomAttempts, maxRooms };
}

// ---------- Map Gen (rooms + corridors) ----------
function makeMap(w, h, roomAttempts, maxRooms) {
  const g = Array.from({length:h}, () => Array.from({length:w}, () => WALL));
  const rooms = [];

  for (let i = 0; i < roomAttempts && rooms.length < maxRooms; i++) {
    const rw = randi(4, 12);
    const rh = randi(4, 10);
    const rx = randi(1, w - rw - 2);
    const ry = randi(1, h - rh - 2);

    const room = { x: rx, y: ry, w: rw, h: rh, cx: rx + (rw >> 1), cy: ry + (rh >> 1) };

    let ok = true;
    for (const r of rooms) {
      const pad = 1;
      if (room.x < r.x + r.w + pad &&
          room.x + room.w + pad > r.x &&
          room.y < r.y + r.h + pad &&
          room.y + room.h + pad > r.y) {
        ok = false; break;
      }
    }
    if (!ok) continue;

    carveRoom(g, room);
    if (rooms.length) connectRooms(g, rooms[rooms.length - 1], room);
    rooms.push(room);
  }

  // Ensure at least one floor blob if weird luck
  if (!rooms.length) {
    carveRoom(g, {x:2,y:2,w:w-4,h:h-4});
  }

  return g;
}

function carveRoom(g, r){
  for (let y = r.y; y < r.y + r.h; y++)
    for (let x = r.x; x < r.x + r.w; x++)
      g[y][x] = FLOOR;
}

function connectRooms(g, a, b){
  let x = a.cx, y = a.cy;
  const tx = b.cx, ty = b.cy;

  if (rng() < 0.5) {
    while (x !== tx) { x += x < tx ? 1 : -1; g[y][x] = FLOOR; }
    while (y !== ty) { y += y < ty ? 1 : -1; g[y][x] = FLOOR; }
  } else {
    while (y !== ty) { y += y < ty ? 1 : -1; g[y][x] = FLOOR; }
    while (x !== tx) { x += x < tx ? 1 : -1; g[y][x] = FLOOR; }
  }
}

function isFloor(x,y){
  return x>=0 && y>=0 && x<W && y<H && map[y][x]===FLOOR;
}

// ---------- Pathing ----------
function bfsDistanceField(from){
  // returns Int16Array distances (or -1)
  const dist = new Int16Array(W * H);
  dist.fill(-1);
  const qx = new Int16Array(W * H);
  const qy = new Int16Array(W * H);
  let qs = 0, qe = 0;

  dist[from.y * W + from.x] = 0;
  qx[qe] = from.x; qy[qe] = from.y; qe++;

  while (qs < qe) {
    const x = qx[qs], y = qy[qs]; qs++;
    const d = dist[y * W + x];

    const n = [
      [x+1,y],[x-1,y],[x,y+1],[x,y-1]
    ];
    for (const [nx,ny] of n) {
      if (!isFloor(nx,ny)) continue;
      const idx = ny * W + nx;
      if (dist[idx] !== -1) continue;
      dist[idx] = d + 1;
      qx[qe] = nx; qy[qe] = ny; qe++;
    }
  }
  return dist;
}

function pathLength(a,b){
  const dist = bfsDistanceField(a);
  return dist[b.y * W + b.x];
}

// ---------- Placement (passable guarantee) ----------
function placeOnFloor(){
  for (let i=0;i<12000;i++){
    const x=randi(1,W-2), y=randi(1,H-2);
    if (isFloor(x,y)) return {x,y};
  }
  map[2][2]=FLOOR; return {x:2,y:2};
}

function samePos(a,b){ return a.x===b.x && a.y===b.y; }

function placeFarEnough(origin, minDist){
  for (let i=0;i<20000;i++){
    const p = placeOnFloor();
    const d = Math.abs(p.x-origin.x)+Math.abs(p.y-origin.y);
    if (d >= minDist) return p;
  }
  return placeOnFloor();
}

function spawnEnemies(count, avoidA, avoidB){
  const arr = [];
  let tries = 0;
  while (arr.length < count && tries < 60000) {
    tries++;
    const e = placeOnFloor();
    if (samePos(e, avoidA) || samePos(e, avoidB)) continue;
    if (Math.abs(e.x-avoidA.x)+Math.abs(e.y-avoidA.y) < 8) continue;
    if (Math.abs(e.x-avoidB.x)+Math.abs(e.y-avoidB.y) < 5) continue;

    let clash = false;
    for (const k of arr) if (samePos(k,e)) { clash = true; break; }
    if (clash) continue;

    arr.push(e);
  }
  return arr;
}

function buildPassableLevel(lv){
  const p = paramsForLevel(lv);

  // loop until we get a passable map + exit with enough path length
  for (let attempt=0; attempt<120; attempt++){
    map = makeMap(W, H, p.roomAttempts, p.maxRooms);

    const pl = placeOnFloor();
    const ex = placeFarEnough(pl, p.minPath);

    const len = pathLength(pl, ex);
    if (len === -1) continue;         // not connected
    if (len < p.minPath) continue;     // too short/easy for this tier

    const ens = spawnEnemies(p.enemyCount, pl, ex);
    // still require exit reachable even with enemies placed (enemies don't block floors permanently)
    player = pl;
    exit = ex;
    enemies = ens;
    return true;
  }

  // fallback: force open space, still passable
  map = Array.from({length:H}, ()=>Array.from({length:W}, ()=>FLOOR));
  for (let y=0;y<H;y++){ map[y][0]=WALL; map[y][W-1]=WALL; }
  for (let x=0;x<W;x++){ map[0][x]=WALL; map[H-1][x]=WALL; }
  player = {x:2,y:2};
  exit = {x:W-3,y:H-3};
  enemies = spawnEnemies(paramsForLevel(lv).enemyCount, player, exit);
  return true;
}

// ---------- Best stats (local) ----------
function bestKey(lv){ return "swyn_roguelike_best_v1_" + lv; }

function loadBest(lv){
  try{
    const raw = localStorage.getItem(bestKey(lv));
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || typeof obj.moves!=="number" || typeof obj.ms!=="number") return null;
    return obj;
  } catch { return null; }
}

function saveBest(lv, ms, moves){
  const cur = loadBest(lv);
  const better = (!cur) || (ms < cur.ms) || (ms === cur.ms && moves < cur.moves);
  if (!better) return false;
  try{
    localStorage.setItem(bestKey(lv), JSON.stringify({ms, moves}));
    return true;
  } catch { return false; }
}

function formatBest(obj){
  if (!obj) return "—";
  return `${obj.moves} moves • ${(obj.ms/1000).toFixed(1)}s`;
}

// ---------- Game loop ----------
function setLevel(lv){
  level = clamp(lv|0, 0, 50);
  levelInput.value = String(level);

  seed = makeSeed();
  rng = mulberry32(hash32(seed));
  seedShort.textContent = seed.slice(0,20) + "…";
  seedFull.textContent = seed;

  alive = true; won = false;
  moves = 0; running = false; startMs = 0;

  const ok = buildPassableLevel(level);
  if (!ok) statusEl.textContent = "Generation failed";
  else statusEl.textContent = "Ready";

  const par = paramsForLevel(level);
  lvlLabel.textContent = String(level);
  tierLabel.textContent = "• " + tierForLevel(level);
  enemyLabel.textContent = String(enemies.length);

  movesRunEl.textContent = "0";
  timeRunEl.textContent = "0.0s";
  bestLabel.textContent = formatBest(loadBest(level));

  hideOverlay();
  draw();
}

function nowMs(){ return performance.now(); }

function startTimerIfNeeded(){
  if (!running){
    running = true;
    startMs = nowMs();
  }
}

function elapsedMs(){
  return running ? Math.max(0, nowMs() - startMs) : 0;
}

function tryMove(dx,dy){
  if (!alive || won) return;

  const nx = clamp(player.x + dx, 0, W-1);
  const ny = clamp(player.y + dy, 0, H-1);
  if (!isFloor(nx,ny)) return;

  startTimerIfNeeded();

  player.x = nx; player.y = ny;
  moves++;
  movesRunEl.textContent = String(moves);
  timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";

  if (player.x===exit.x && player.y===exit.y){
    won = true;
    alive = true;
    onWin();
    draw();
    return;
  }

  enemyTurn();
  checkLose();

  timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";
  draw();
}

function checkLose(){
  for (const e of enemies){
    if (e.x===player.x && e.y===player.y){
      alive = false;
      statusEl.textContent = `Dead • ${moves} moves • ${(elapsedMs()/1000).toFixed(1)}s`;
      showOverlay("You died", `Level ${level} failed.<br><br>Run: <b>${moves}</b> moves • <b>${(elapsedMs()/1000).toFixed(1)}s</b><br><span class="muted">Retry with R.</span>`);
      return;
    }
  }
}

function onWin(){
  const ms = elapsedMs();
  const t = (ms/1000).toFixed(1);

  const updated = saveBest(level, ms, moves);
  bestLabel.textContent = formatBest(loadBest(level));

  statusEl.textContent = `Level passed • ${moves} moves • ${t}s`;

  const msg = [
    `Level <b>${level}</b> passed.`,
    `Run: <b>${moves}</b> moves • <b>${t}s</b>`,
    updated ? `<span class="muted">New best saved for this browser.</span>` : `<span class="muted">Best unchanged for this browser.</span>`,
    `<span class="muted">Next: N</span>`
  ].join("<br><br>");

  showOverlay("Level Complete", msg);
}

function enemyTurn(){
  const par = paramsForLevel(level);

  for (let step=0; step<par.enemySteps; step++){
    // distance field from player (for chase)
    const dist = bfsDistanceField(player);

    for (const e of enemies){
      // already on player
      if (e.x===player.x && e.y===player.y) continue;

      const options = [
        {x:e.x+1,y:e.y},{x:e.x-1,y:e.y},{x:e.x,y:e.y+1},{x:e.x,y:e.y-1}
      ].filter(p => isFloor(p.x,p.y));

      let best = null;
      let bestD = 1e9;

      for (const p of options){
        const d = dist[p.y*W + p.x];
        if (d === -1) continue;
        if (d < bestD){
          bestD = d;
          best = p;
        }
      }

      // if something weird happens, random move
      if (!best && options.length) best = options[randi(0, options.length-1)];

      if (best){
        e.x = best.x; e.y = best.y;
      }
    }

    // after each enemy step, check immediate loss
    for (const e of enemies){
      if (e.x===player.x && e.y===player.y){
        alive = false;
        statusEl.textContent = `Dead • ${moves} moves • ${(elapsedMs()/1000).toFixed(1)}s`;
        showOverlay("You died", `Level ${level} failed.<br><br>Run: <b>${moves}</b> moves • <b>${(elapsedMs()/1000).toFixed(1)}s</b><br><span class="muted">Retry with R.</span>`);
        return;
      }
    }
  }
}

// ---------- Render ----------
function draw(){
  // background
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // tiles
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      ctx.fillStyle = (map[y][x]===WALL) ? "#0a0f16" : "#121b26";
      ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
    }
  }

  // exit
  ctx.fillStyle = "#39d98a";
  ctx.fillRect(exit.x*TILE+4, exit.y*TILE+4, TILE-8, TILE-8);

  // enemies
  ctx.fillStyle = "#ff4d4d";
  for (const e of enemies){
    ctx.fillRect(e.x*TILE+4, e.y*TILE+4, TILE-8, TILE-8);
  }

  // player
  ctx.fillStyle = "#e6edf3";
  ctx.fillRect(player.x*TILE+3, player.y*TILE+3, TILE-6, TILE-6);

  // overlay text on canvas
  ctx.fillStyle = "rgba(255,255,255,0.72)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText(`Moves: ${moves}`, 10, 16);
  ctx.fillText(`Enemies: ${enemies.length}`, 10, 32);
  ctx.fillText(`Goal: reach green`, 10, 48);

  if (!alive){
    ctx.fillStyle = "rgba(255,77,77,0.85)";
    ctx.fillText(`DEAD`, 10, 64);
  } else if (won){
    ctx.fillStyle = "rgba(57,217,138,0.85)";
    ctx.fillText(`WIN`, 10, 64);
  }
}

// ---------- Overlay ----------
function showOverlay(title, html){
  overlayTitle.textContent = title;
  overlayBody.innerHTML = html;
  overlay.style.display = "grid";
}
function hideOverlay(){
  overlay.style.display = "none";
}

// ---------- UI / Controls ----------
function gotoLevelFromInput(){
  const n = Number(levelInput.value);
  if (!Number.isFinite(n)) return;
  setLevel(n|0);
}

goBtn.addEventListener("click", gotoLevelFromInput);
levelInput.addEventListener("keydown", (e)=>{ if (e.key==="Enter") gotoLevelFromInput(); });

resetBestBtn.addEventListener("click", ()=>{
  try { localStorage.removeItem(bestKey(level)); } catch {}
  bestLabel.textContent = "—";
});

nextBtn.addEventListener("click", ()=> setLevel(Math.min(50, level+1)));
retryBtn.addEventListener("click", ()=> setLevel(level));
closeBtn.addEventListener("click", hideOverlay);

addEventListener("keydown", (e)=>{
  const k = e.key.toLowerCase();

  // always allow overlay navigation
  if (k==="n"){ e.preventDefault(); setLevel(Math.min(50, level+1)); return; }
  if (k==="p"){ e.preventDefault(); setLevel(Math.max(0, level-1)); return; }
  if (k==="r"){ e.preventDefault(); setLevel(level); return; }

  // ignore movement if input focused
  const ae = document.activeElement;
  if (ae && (ae.tagName==="INPUT" || ae.tagName==="TEXTAREA")) return;

  if (k==="arrowup" || k==="w"){ e.preventDefault(); tryMove(0,-1); }
  else if (k==="arrowdown" || k==="s"){ e.preventDefault(); tryMove(0,1); }
  else if (k==="arrowleft" || k==="a"){ e.preventDefault(); tryMove(-1,0); }
  else if (k==="arrowright" || k==="d"){ e.preventDefault(); tryMove(1,0); }
});

// tick run time display even if you pause
setInterval(()=>{
  if (running && alive && !won){
    timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";
  }
}, 100);

setLevel(0);
</script>
</body>
</html>
