<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Type Racer — SureWhyNot</title>
  <link rel="stylesheet" href="/assets/site.css">

  <!-- 1) DROP THIS CSS into typeracer.html (replace ALL your .veh.* CSS) -->
<style>
  /* Unified icon sizing + style */
  .veh {
    width: 46px;
    height: 28px;
    display: inline-grid;
    place-items: center;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,.40));
  }
  .veh svg { width: 46px; height: 28px; display:block; }

  /* Same look across all icons */
  .veh .stroke { stroke: rgba(0,0,0,.55); stroke-width: 1.2; stroke-linecap: round; stroke-linejoin: round; }
  .veh .metal  { fill: rgba(255,255,255,.10); }
  .veh .glass  { fill: rgba(120,220,255,.35); }

  /* Per-vehicle accent colors (kept consistent + dev-site friendly) */
  .veh.truck  { --a1:#31d18b; --a2:#157a57; }
  .veh.plane  { --a1:#6cc7ff; --a2:#2457c6; }
  .veh.f1     { --a1:#ff4b4b; --a2:#8b1010; }
  .veh.boat   { --a1:#ffd166; --a2:#b65d00; }

  .veh .accent { fill: url(#gradAccent); }
  .veh .shade  { fill: rgba(0,0,0,.18); }
  .veh .tire   { fill: #141414; }
  .veh .rim    { fill: #a9a9a9; }
</style>

</head>

<script>
async function loadPartials() {
  const header = await fetch('/partials/header.html');
  const footer = await fetch('/partials/footer.html');

  document.getElementById('site-header').innerHTML = await header.text();
  document.getElementById('site-footer').innerHTML = await footer.text();

  if (window.SWY_renderToolUse) window.SWY_renderToolUse();
}
loadPartials();
</script>

<body>
  <div class="page">
    <div id="site-header"></div>

    <main>
      <div class="wrap">
        <section class="racegrid">
          <div class="card">
            <div class="pad">
              <div class="h1">Type Racer</div>
              <div class="muted">
                Join lobby to find a real match. If nobody joins by the end of the timer, no race starts — you can leave and practice solo or try again.
              </div>

              <div class="btnrow">
                <button class="primary" id="btnEnter">Join Lobby</button>
                <button id="btnPractice">Practice Solo</button>
                <button id="btnLeave" disabled>Leave</button>
                <button id="btnNew" disabled>Try Again</button>
              </div>

              <div class="track" aria-label="Race track">
                <div class="finish" aria-hidden="true"></div>

                <div class="lane">
                  <div class="runner" id="r1">
                    <div class="veh truck" title="monster truck"></div>
                    <span class="badge" id="n1">You</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="r2">
                    <div class="veh plane" title="airplane"></div>
                    <span class="badge" id="n2">Waiting…</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="r3">
                    <div class="veh f1" title="formula 1"></div>
                    <span class="badge" id="n3">Waiting…</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="r4">
                    <div class="veh boat" title="boat"></div>
                    <span class="badge" id="n4">Waiting…</span>
                  </div>
                </div>
              </div>

              <div class="hr"></div>

              <div class="muted" id="raceText"></div>
              <textarea id="input" placeholder="Type here when the race begins…" disabled></textarea>

              <div class="statrow">
                <div class="stat">WPM <b id="wpm">0</b></div>
                <div class="stat">Accuracy <b id="acc">100%</b></div>
                <div class="stat">Time <b id="time">0.0s</b></div>
              </div>

              <div class="lobbybox" id="lobbyBox">
                <div><b style="color:var(--text)">Lobby</b></div>
                <div class="tiny" id="lobbyStatus">Not in a lobby.</div>
                <ul class="lobbylist" id="lobbyList"></ul>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="pad">
              <div class="h1">How it works</div>
              <div class="muted">
                - Lobby match timer runs when you join. <br>
                - Race only starts if 2+ real players are present. <br>
                - Practice mode is always available. <br>
                - Everything runs client-side (same-device tabs only for now).
              </div>

              <div class="hr"></div>

              <div class="adslot">
                <div style="font-size:12px;color:var(--muted);margin-bottom:10px;">
                  Keep this spot consistent so the layout doesn’t jump later.
                </div>
                <b>[ AdSense Slot Here ]</b>
              </div>
            </div>
          </div>
        </section>
      </div>
    </main>

    <div id="site-footer"></div>
  </div>

<script>
(() => {
  // ====== Race text ======
  const TEXT = [
    "Race clean and steady.",
    "Accuracy first, speed second.",
    "One character at a time.",
    "Finish strong."
  ].join(" ");

  const elRaceText = document.getElementById("raceText");
  const input = document.getElementById("input");

  const btnEnter = document.getElementById("btnEnter");
  const btnPractice = document.getElementById("btnPractice");
  const btnLeave = document.getElementById("btnLeave");
  const btnNew = document.getElementById("btnNew");

  const wpmEl = document.getElementById("wpm");
  const accEl = document.getElementById("acc");
  const timeEl = document.getElementById("time");

  const lobbyStatus = document.getElementById("lobbyStatus");
  const lobbyList = document.getElementById("lobbyList");

  // lanes
  const runners = [
    document.getElementById("r1"),
    document.getElementById("r2"),
    document.getElementById("r3"),
    document.getElementById("r4"),
  ];
  const names = [
    document.getElementById("n1"),
    document.getElementById("n2"),
    document.getElementById("n3"),
    document.getElementById("n4"),
  ];

  elRaceText.textContent = TEXT;

  // ====== goofy names ======
  const ADJ = ["Sleepy","Spicy","Quantum","Cranky","Sneaky","Turbo","Glitchy","Wobbly","Moody","Cosmic","Rusty","Chaotic","Polite","Ferocious","Tiny","Big","Nervous","Chill","Saucy","Gremlin"];
  const NOUN = ["Nginx","Kernel","Panda","Router","Yeti","Byte","Packet","Goblin","Octopus","Unicorn","Linter","Daemon","Banana","Squirrel","Dragon","Proxy","Hash","Socket","Wombat","Cactus"];
  function randInt(n){
    const a = new Uint32Array(1);
    crypto.getRandomValues(a);
    return a[0] % n;
  }
  function goofyName(){
    return ADJ[randInt(ADJ.length)] + " " + NOUN[randInt(NOUN.length)];
  }

  // ====== Lobby (same-device tabs only) ======
  const channel = new BroadcastChannel("surewhynot-typeracer-lobby-v3");
  const myId = crypto.randomUUID().slice(0, 10);
  const myName = goofyName();

  let lobby = new Map(); // id -> {name, ts}
  let inLobby = false;

  // ====== Session/race state ======
  let mode = "idle"; // idle | lobby | practice | race
  let startedAt = null;
  let finished = false;

  // lobby timers
  let matchTimer = null;
  let matchSecondsLeft = 0;

  let raceCountdownTimer = null;
  let raceCountdownLeft = 0;

  // progress per player id
  let progress = new Map(); // id -> correct chars

  // ---------- UI helpers ----------
  function setLobbyStatus(text){ lobbyStatus.textContent = text; }
  function renderLobby() {
    lobbyList.innerHTML = "";
    const entries = Array.from(lobby.values()).map(x => x.name).sort();
    entries.forEach(n => {
      const li = document.createElement("li");
      li.textContent = n;
      lobbyList.appendChild(li);
    });
  }

  function setRunner(el, progress01) {
    const track = document.querySelector(".track");
    const lanePaddingLeft = 8;
    const finishPaddingRight = 22;
    const max = track.clientWidth - lanePaddingLeft - finishPaddingRight;
    const x = Math.max(0, Math.min(1, progress01)) * max;
    el.style.transform = `translateX(${x}px)`;
  }

  function resetTrack() {
    runners.forEach(r => setRunner(r, 0));
  }

  function charsDoneToProgress(charsDone){ return charsDone / TEXT.length; }

  function calcWPM(charsCorrect, seconds) {
    if (seconds <= 0) return 0;
    const words = charsCorrect / 5;
    const minutes = seconds / 60;
    return Math.round(words / minutes);
  }

  function computeCorrectChars(typed) {
    const max = Math.min(typed.length, TEXT.length);
    let correct = 0;
    for (let i = 0; i < max; i++) {
      if (typed[i] === TEXT[i]) correct++;
      else break;
    }
    return correct;
  }

  function updateStats(youCorrect, youTotal) {
    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;
    timeEl.textContent = seconds.toFixed(1) + "s";
    wpmEl.textContent = calcWPM(youCorrect, seconds);
    const acc = youTotal ? Math.round((youCorrect / youTotal) * 100) : 100;
    accEl.textContent = acc + "%";
  }

  function setButtons() {
    const idle = mode === "idle";
    btnEnter.disabled = !idle;
    btnPractice.disabled = !idle;
    btnLeave.disabled = idle;
    btnNew.disabled = !(mode === "lobby" || mode === "practice" || mode === "race");
  }

  function stopMatchTimer(){
    if(matchTimer) clearInterval(matchTimer);
    matchTimer = null;
    matchSecondsLeft = 0;
  }

  function stopRaceCountdown(){
    if(raceCountdownTimer) clearInterval(raceCountdownTimer);
    raceCountdownTimer = null;
    raceCountdownLeft = 0;
  }

  function realPlayers(){
    return Array.from(lobby.entries()).map(([id,v]) => ({id, name:v.name}));
  }

  function assignLanes(){
    // lane 1 is always "You"
    names[0].textContent = myName + " (You)";

    // other lanes are other real players in deterministic order
    const others = realPlayers().filter(p => p.id !== myId).sort((a,b) => a.id.localeCompare(b.id));

    const labels = ["Waiting…", "Waiting…", "Waiting…"];
    for(let i=0;i<3;i++){
      names[i+1].textContent = labels[i];
      setRunner(runners[i+1], 0); // ensure they don't move unless real player has progress
    }

    for(let i=0;i<Math.min(3, others.length);i++){
      names[i+1].textContent = others[i].name;
    }
  }

  // ---------- Lobby logic ----------
  function joinLobby() {
    // clean state
    stopMatchTimer();
    stopRaceCountdown();
    progress.clear();
    resetTrack();

    lobby.clear();
    lobby.set(myId, { name: myName, ts: Date.now() });
    inLobby = true;
    mode = "lobby";
    setButtons();

    channel.postMessage({ type: "join", id: myId, name: myName, ts: Date.now() });
    channel.postMessage({ type: "sync", from: myId });

    input.disabled = true;
    input.value = "";
    finished = false;
    startedAt = null;

    renderLobby();
    assignLanes();
    updateStats(0,0);

    // Start matchmaking timer even if you're alone
    matchSecondsLeft = 15;
    setLobbyStatus(`Searching… (${matchSecondsLeft}s)`);
    matchTimer = setInterval(() => {
      matchSecondsLeft--;
      const count = lobby.size;
      if (count >= 2) {
        stopMatchTimer();
        startRaceCountdownIfReady();
        return;
      }
      if (matchSecondsLeft > 0) {
        setLobbyStatus(`Searching… (${matchSecondsLeft}s)`);
        return;
      }
      stopMatchTimer();
      setLobbyStatus("No match found. Leave, practice solo, or try again.");
      // no race starts
    }, 1000);
  }

  function leaveLobby() {
    stopMatchTimer();
    stopRaceCountdown();
    if (inLobby) channel.postMessage({ type: "leave", id: myId });

    inLobby = false;
    lobby.clear();
    progress.clear();
    renderLobby();

    mode = "idle";
    setLobbyStatus("Not in a lobby.");
    input.disabled = true;
    input.value = "";
    finished = false;
    startedAt = null;
    resetTrack();
    assignLanes();
    updateStats(0,0);
    setButtons();
  }

  function startRaceCountdownIfReady(){
    if (mode !== "lobby") return;
    if (lobby.size < 2) return;

    if (raceCountdownTimer) return;

    raceCountdownLeft = 5;
    setLobbyStatus(`Match found. Race starts in ${raceCountdownLeft}s…`);
    channel.postMessage({ type: "countdown", seconds: raceCountdownLeft, ts: Date.now() });

    raceCountdownTimer = setInterval(() => {
      raceCountdownLeft--;
      if (raceCountdownLeft > 0) {
        setLobbyStatus(`Match found. Race starts in ${raceCountdownLeft}s…`);
        channel.postMessage({ type: "countdown", seconds: raceCountdownLeft, ts: Date.now() });
        return;
      }
      stopRaceCountdown();
      const startTs = Date.now() + 200; // cushion
      channel.postMessage({ type: "start", startTs, text: TEXT });
      beginRace(startTs);
    }, 1000);
  }

  // ---------- Practice mode ----------
  function beginPractice() {
    leaveLobby();
    mode = "practice";
    setButtons();

    finished = false;
    startedAt = performance.now();
    resetTrack();
    assignLanes();
    updateStats(0,0);

    input.disabled = false;
    input.value = "";
    input.focus();

    setLobbyStatus("Practice mode. Just you.");
  }

  // ---------- Multiplayer race ----------
  function beginRace(startTs) {
    mode = "race";
    setButtons();

    stopMatchTimer();
    stopRaceCountdown();

    finished = false;
    progress.set(myId, 0);

    resetTrack();
    assignLanes();
    updateStats(0,0);

    input.disabled = true;
    input.value = "";

    const delay = Math.max(0, startTs - Date.now());
    setLobbyStatus("Race starting…");
    setTimeout(() => {
      if (mode !== "race") return;
      startedAt = performance.now();
      input.disabled = false;
      input.focus();
      setLobbyStatus("Race started. Type now.");
      requestAnimationFrame(tickRace);
    }, delay);
  }

  function tickRace() {
    if (mode !== "race" || finished) return;

    // update lane progress for real players only
    assignLanes();

    const players = realPlayers().sort((a,b)=>a.id.localeCompare(b.id));
    // lane mapping: you lane1, then first 3 others lanes 2-4
    const others = players.filter(p => p.id !== myId);

    // lane1 you
    const youC = progress.get(myId) || 0;
    setRunner(runners[0], charsDoneToProgress(youC));

    // lanes 2-4 for actual others, otherwise stay still
    for(let i=0;i<3;i++){
      const p = others[i];
      if (!p) { setRunner(runners[i+1], 0); continue; }
      const c = progress.get(p.id) || 0;
      setRunner(runners[i+1], charsDoneToProgress(c));
    }

    // finish if you done
    if (charsDoneToProgress(youC) >= 1) {
      finishRace();
      return;
    }

    requestAnimationFrame(tickRace);
  }

  function finishRace(){
    finished = true;
    input.disabled = true;

    const youC = progress.get(myId) || 0;
    const youTotal = input.value.length || 0;
    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;
    const finalWpm = calcWPM(youC, seconds);

    if (mode === "practice") {
      setLobbyStatus(`Practice finished. WPM: ${finalWpm}.`);
    } else {
      setLobbyStatus(`Finished. WPM: ${finalWpm}.`);
      // keep lobby simple: you can leave or try again
    }
  }

  // ---------- Input ----------
  input.addEventListener("input", () => {
    if (!startedAt || finished) return;

    const typed = input.value;
    const youTotal = typed.length;
    const youCorrect = computeCorrectChars(typed);

    progress.set(myId, youCorrect);

    // update stats
    updateStats(youCorrect, youTotal);

    // move you immediately
    setRunner(runners[0], charsDoneToProgress(youCorrect));

    // broadcast progress only in race+lobby
    if (mode === "race" && inLobby) {
      channel.postMessage({ type: "progress", id: myId, correct: youCorrect, ts: Date.now() });
    }

    if (typed.length > TEXT.length) {
      input.value = typed.slice(0, TEXT.length);
    }

    if (charsDoneToProgress(youCorrect) >= 1) finishRace();
  });

  // ---------- BroadcastChannel messages ----------
  channel.onmessage = (ev) => {
    const msg = ev.data || {};

    if (msg.type === "join") {
      lobby.set(msg.id, { name: msg.name, ts: msg.ts || Date.now() });
      renderLobby();
      assignLanes();

      // if match timer still running and we now have 2+, start countdown
      if (mode === "lobby" && lobby.size >= 2) {
        stopMatchTimer();
        startRaceCountdownIfReady();
      }
    }

    if (msg.type === "leave") {
      lobby.delete(msg.id);
      progress.delete(msg.id);
      renderLobby();
      assignLanes();

      // if we were counting down and lost players, stop countdown
      if (mode === "lobby" && lobby.size < 2) {
        stopRaceCountdown();
        // restart match timer if you want to keep searching
        if (!matchTimer) {
          matchSecondsLeft = 10;
          setLobbyStatus(`Searching… (${matchSecondsLeft}s)`);
          matchTimer = setInterval(() => {
            matchSecondsLeft--;
            if (lobby.size >= 2) {
              stopMatchTimer();
              startRaceCountdownIfReady();
              return;
            }
            if (matchSecondsLeft > 0) {
              setLobbyStatus(`Searching… (${matchSecondsLeft}s)`);
              return;
            }
            stopMatchTimer();
            setLobbyStatus("No match found. Leave, practice solo, or try again.");
          }, 1000);
        }
      }
    }

    if (msg.type === "sync" && inLobby) {
      channel.postMessage({
        type: "roster",
        to: msg.from,
        roster: Array.from(lobby.entries()).map(([id, v]) => [id, v.name, v.ts])
      });
    }

    if (msg.type === "roster" && msg.to === myId) {
      msg.roster.forEach(([id, name, ts]) => {
        lobby.set(id, { name, ts: ts || Date.now() });
      });
      renderLobby();
      assignLanes();

      if (mode === "lobby" && lobby.size >= 2) {
        stopMatchTimer();
        startRaceCountdownIfReady();
      }
    }

    if (msg.type === "countdown" && mode === "lobby") {
      if (lobby.size < 2) return;
      raceCountdownLeft = Number(msg.seconds || 0);
      if (raceCountdownLeft > 0) setLobbyStatus(`Match found. Race starts in ${raceCountdownLeft}s…`);
    }

    if (msg.type === "start") {
      if (mode === "lobby" && lobby.size >= 2) {
        beginRace(msg.startTs);
      }
    }

    if (msg.type === "progress") {
      // only track real players; ignore if not in race
      if (mode !== "race") return;
      if (!lobby.has(msg.id)) return;
      progress.set(msg.id, Math.max(0, Number(msg.correct || 0)));
    }
  };

  // ---------- Buttons ----------
  btnEnter.addEventListener("click", joinLobby);
  btnPractice.addEventListener("click", beginPractice);
  btnLeave.addEventListener("click", leaveLobby);

  btnNew.addEventListener("click", () => {
    // Try Again behavior:
    if (mode === "practice") {
      beginPractice();
      return;
    }
    // From lobby: restart search
    if (mode === "lobby") {
      leaveLobby();
      joinLobby();
      return;
    }
    // From race: leave and rejoin lobby search
    if (mode === "race") {
      leaveLobby();
      joinLobby();
    }
  });

  window.addEventListener("beforeunload", () => {
    if (inLobby) channel.postMessage({ type: "leave", id: myId });
  });

  // init
  resetTrack();
  assignLanes();
  renderLobby();
  setButtons();
  setLobbyStatus("Not in a lobby.");
})();
</script>
</body>
</html>
