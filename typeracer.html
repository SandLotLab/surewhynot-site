<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Type Racer — SureWhyNot</title>
  <link rel="stylesheet" href="/assets/site.css">
  <style>
    /* page-specific */
    .racegrid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
      padding:22px 0 26px;
    }
    @media (max-width: 900px){ .racegrid{grid-template-columns:1fr} }

    .btnrow{display:flex; gap:10px; flex-wrap:wrap; margin:12px 0 10px}
    button{
      appearance:none;
      border:1px solid rgba(23,36,59,.85);
      background: linear-gradient(to bottom, rgba(11,21,40,.85), rgba(11,21,40,.55));
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-family:inherit;
      cursor:pointer;
      font-size:13px;
    }
    button:hover{background: linear-gradient(to bottom, rgba(12,25,49,.9), rgba(12,25,49,.55))}
    button.primary{border-color: rgba(246,195,74,.55)}
    button:disabled{opacity:.55; cursor:not-allowed}

    .track{
      border:1px solid rgba(23,36,59,.85);
      border-radius:14px;
      background: rgba(10,15,24,.35);
      padding:12px;
      overflow:hidden;
      position:relative;
      height:240px;
    }
    .lane{
      position:relative;
      height:52px;
      border-bottom:1px dashed rgba(23,36,59,.55);
      display:flex;
      align-items:center;
      padding-left:8px;
    }
    .lane:last-child{border-bottom:none}
    .runner{
      position:absolute;
      left:8px;
      display:flex;
      align-items:center;
      gap:10px;
      transform: translateX(0);
      transition: transform 120ms linear;
      will-change: transform;
    }
    .badge{
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(23,36,59,.85);
      background: rgba(11,21,40,.75);
      padding:4px 8px;
      border-radius:999px;
    }

    /* “objects” (no emoji) */
    .obj{
      width:28px;height:18px;
      border-radius:6px;
      border:1px solid rgba(23,36,59,.85);
      background: rgba(246,195,74,.18);
      position:relative;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
    }
    .obj::after{
      content:"";
      position:absolute;
      right:-6px; top:6px;
      width:8px;height:6px;
      border-radius:0 6px 6px 0;
      background: rgba(246,195,74,.35);
      border:1px solid rgba(23,36,59,.85);
    }
    .obj.car{border-radius:7px}
    .obj.plane{clip-path: polygon(0 50%, 25% 20%, 70% 20%, 100% 50%, 70% 80%, 25% 80%)}
    .obj.ele{width:30px;height:20px;border-radius:10px}
    .obj.ant{width:22px;height:14px;border-radius:999px}

    .finish{
      position:absolute;
      right:10px;
      top:12px;
      bottom:12px;
      width:10px;
      border-radius:8px;
      background: repeating-linear-gradient(
        to bottom,
        rgba(246,195,74,.85) 0px,
        rgba(246,195,74,.85) 10px,
        rgba(246,195,74,.15) 10px,
        rgba(246,195,74,.15) 20px
      );
      opacity:.9;
    }

    textarea{
      width:100%;
      min-height:86px;
      resize:vertical;
      border-radius:12px;
      border:1px solid rgba(23,36,59,.85);
      background: rgba(11,21,40,.45);
      color:var(--text);
      padding:12px;
      font-family:inherit;
      font-size:13px;
      outline:none;
    }
    textarea:disabled{opacity:.55}

    .statrow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .stat{
      border:1px solid rgba(23,36,59,.85);
      background: rgba(11,21,40,.35);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--muted);
    }
    .stat b{display:block; color:var(--text); font-size:14px; margin-top:2px}

    .lobbybox{
      border:1px solid rgba(23,36,59,.85);
      background: rgba(11,21,40,.35);
      border-radius:12px;
      padding:12px;
      margin-top:10px;
      font-size:12.5px;
      color:var(--muted);
      line-height:1.5;
    }
    .lobbylist{margin:8px 0 0; padding-left:18px}
    .tiny{font-size:12px;color:var(--muted)}
  </style>
</head>

<script>
async function loadPartials() {
  const header = await fetch('/partials/header.html');
  const footer = await fetch('/partials/footer.html');

  document.getElementById('site-header').innerHTML = await header.text();
  document.getElementById('site-footer').innerHTML = await footer.text();

  if (window.SWY_renderToolUse) window.SWY_renderToolUse();
}
loadPartials();
</script>

<body>
  <div class="page">
    <div id="site-header"></div>

    <main>
      <div class="wrap">
        <section class="racegrid">
          <div class="card">
            <div class="pad">
              <div class="h1">Type Racer</div>
              <div class="muted">
                Multiplayer races only start when at least <span class="kbd">2</span> real players are in the lobby.
                Practice mode lets you race yourself with no NPC movement.
              </div>

              <div class="btnrow">
                <button class="primary" id="btnEnter">Enter Lobby</button>
                <button id="btnPractice">Practice Solo</button>
                <button id="btnLeave" disabled>Leave</button>
                <button id="btnNew" disabled>New Race</button>
              </div>

              <div class="track" aria-label="Race track">
                <div class="finish" aria-hidden="true"></div>

                <div class="lane">
                  <div class="runner" id="rYou">
                    <div class="obj car" title="car"></div>
                    <span class="badge">You</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="rOpp">
                    <div class="obj plane" title="opponent"></div>
                    <span class="badge" id="oppName">Opponent</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="rGhost">
                    <div class="obj ele" title="ghost"></div>
                    <span class="badge" id="ghostName">Your Best</span>
                  </div>
                </div>

                <div class="lane">
                  <div class="runner" id="rLine">
                    <div class="obj ant" title="pace"></div>
                    <span class="badge">Pace</span>
                  </div>
                </div>
              </div>

              <div class="hr"></div>

              <div class="muted" id="raceText"></div>
              <textarea id="input" placeholder="Type here when the race begins…" disabled></textarea>

              <div class="statrow">
                <div class="stat">WPM <b id="wpm">0</b></div>
                <div class="stat">Accuracy <b id="acc">100%</b></div>
                <div class="stat">Time <b id="time">0.0s</b></div>
              </div>

              <div class="lobbybox" id="lobbyBox">
                <div><b style="color:var(--text)">Lobby</b></div>
                <div class="tiny" id="lobbyStatus">Not in a lobby.</div>
                <ul class="lobbylist" id="lobbyList"></ul>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="pad">
              <div class="h1">How it works</div>
              <div class="muted">
                - Practice mode: only you move. <br>
                - Multiplayer: race starts only when 2+ real players are present. <br>
                - “Your Best” is a ghost pace based on your best local WPM. <br>
                - Everything runs client-side — no accounts, no uploads.
              </div>

              <div class="hr"></div>

              <div class="adslot">
                <div style="font-size:12px;color:var(--muted);margin-bottom:10px;">
                  Keep this spot consistent so the layout doesn’t jump later.
                </div>
                <b>[ AdSense Slot Here ]</b>
              </div>
            </div>
          </div>
        </section>
      </div>
    </main>

    <div id="site-footer"></div>
  </div>

<script>
(() => {
  // ====== Race text ======
  const TEXT = [
    "A quiet site can still feel alive when people choose to play.",
    "Type steady and keep your eyes on the next word, not the finish line.",
    "Speed comes from calm hands and clean rhythm, not panic.",
    "Finish clean, and the race ends when your last character lands."
  ].join(" ");

  const elRaceText = document.getElementById("raceText");
  const input = document.getElementById("input");

  const btnEnter = document.getElementById("btnEnter");
  const btnPractice = document.getElementById("btnPractice");
  const btnLeave = document.getElementById("btnLeave");
  const btnNew = document.getElementById("btnNew");

  const wpmEl = document.getElementById("wpm");
  const accEl = document.getElementById("acc");
  const timeEl = document.getElementById("time");

  const lobbyStatus = document.getElementById("lobbyStatus");
  const lobbyList = document.getElementById("lobbyList");

  const rYou = document.getElementById("rYou");
  const rOpp = document.getElementById("rOpp");
  const rGhost = document.getElementById("rGhost");
  const rLine = document.getElementById("rLine");

  const oppName = document.getElementById("oppName");
  const ghostName = document.getElementById("ghostName");

  elRaceText.textContent = TEXT;

  // ====== local ghost pace ======
  const BEST_KEY = "swy_typeracer_best_wpm";
  function getBestWpm(){ return Number(localStorage.getItem(BEST_KEY) || "0"); }
  function setBestWpm(n){ localStorage.setItem(BEST_KEY, String(n)); }

  // ====== Lobby (same-device tabs) ======
  const channel = new BroadcastChannel("surewhynot-typeracer-lobby-v2");
  const myId = crypto.randomUUID().slice(0, 8);
  const myName = "Guest-" + myId;

  let lobby = new Map(); // id -> {name, ts}
  let inLobby = false;

  // ====== Session/race state ======
  let mode = "idle"; // idle | lobby | practice | race
  let countdown = 0;
  let countdownTimer = null;

  let startedAt = null;
  let finished = false;

  // opponent progress (multiplayer)
  let oppCorrect = 0;

  // ghost/pace
  let ghostCorrect = 0;
  let paceCorrect = 0;

  // you
  let youCorrect = 0;
  let youTotal = 0;

  // ---------- UI helpers ----------
  function setLobbyStatus(text){ lobbyStatus.textContent = text; }
  function renderLobby() {
    lobbyList.innerHTML = "";
    const entries = Array.from(lobby.values()).map(x => x.name).sort();
    entries.forEach(n => {
      const li = document.createElement("li");
      li.textContent = n;
      lobbyList.appendChild(li);
    });
  }

  function setRunner(el, progress01) {
    const track = document.querySelector(".track");
    const lanePaddingLeft = 8;
    const finishPaddingRight = 22;
    const max = track.clientWidth - lanePaddingLeft - finishPaddingRight;
    const x = Math.max(0, Math.min(1, progress01)) * max;
    el.style.transform = `translateX(${x}px)`;
  }

  function resetTrack() {
    setRunner(rYou, 0);
    setRunner(rOpp, 0);
    setRunner(rGhost, 0);
    setRunner(rLine, 0);
  }

  function charsDoneToProgress(charsDone){ return charsDone / TEXT.length; }

  function calcWPM(charsCorrect, seconds) {
    if (seconds <= 0) return 0;
    const words = charsCorrect / 5;
    const minutes = seconds / 60;
    return Math.round(words / minutes);
  }

  function computeCorrectChars(typed) {
    const max = Math.min(typed.length, TEXT.length);
    let correct = 0;
    for (let i = 0; i < max; i++) {
      if (typed[i] === TEXT[i]) correct++;
      else break;
    }
    return correct;
  }

  function updateStats() {
    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;
    timeEl.textContent = seconds.toFixed(1) + "s";
    wpmEl.textContent = calcWPM(youCorrect, seconds);
    const acc = youTotal ? Math.round((youCorrect / youTotal) * 100) : 100;
    accEl.textContent = acc + "%";
  }

  function setButtons() {
    const idle = mode === "idle";
    btnEnter.disabled = !idle;
    btnPractice.disabled = !idle;
    btnLeave.disabled = idle;
    btnNew.disabled = !(mode === "practice" || mode === "race");
  }

  function stopCountdown(){
    if (countdownTimer) clearInterval(countdownTimer);
    countdownTimer = null;
    countdown = 0;
  }

  // ---------- Lobby logic ----------
  function joinLobby() {
    lobby.clear();
    lobby.set(myId, { name: myName, ts: Date.now() });
    inLobby = true;
    mode = "lobby";
    oppName.textContent = "Opponent";
    setButtons();

    channel.postMessage({ type: "join", id: myId, name: myName, ts: Date.now() });
    channel.postMessage({ type: "sync", from: myId });

    setLobbyStatus("In lobby. Waiting for another player…");
    renderLobby();

    input.disabled = true;
    input.value = "";
    finished = false;
    startedAt = null;
    youCorrect = 0; youTotal = 0;
    oppCorrect = 0;
    resetTrack();
    updateStats();
  }

  function leaveLobby() {
    stopCountdown();
    if (inLobby) channel.postMessage({ type: "leave", id: myId });
    inLobby = false;
    lobby.clear();
    renderLobby();
    mode = "idle";
    setLobbyStatus("Not in a lobby.");
    input.disabled = true;
    input.value = "";
    finished = false;
    startedAt = null;
    resetTrack();
    updateStats();
    setButtons();
  }

  function realPlayersCount(){
    return Array.from(lobby.keys()).length;
  }

  function pickOpponentName(){
    const others = Array.from(lobby.entries()).filter(([id]) => id !== myId);
    if (!others.length) return null;
    return others[0][1].name;
  }

  function startCountdownIfReady() {
    if (mode !== "lobby") return;

    const count = realPlayersCount();
    if (count < 2) {
      stopCountdown();
      setLobbyStatus("In lobby. Waiting for another player…");
      return;
    }

    // already counting down
    if (countdownTimer) return;

    countdown = 5;
    const opp = pickOpponentName();
    if (opp) oppName.textContent = opp;

    channel.postMessage({ type: "countdown", seconds: countdown, startedBy: myId, ts: Date.now() });

    setLobbyStatus(`Match found. Race starts in ${countdown}s…`);
    countdownTimer = setInterval(() => {
      countdown--;
      if (countdown > 0) {
        setLobbyStatus(`Match found. Race starts in ${countdown}s…`);
        channel.postMessage({ type: "countdown", seconds: countdown, startedBy: myId, ts: Date.now() });
        return;
      }
      stopCountdown();
      // host starts the race (shared start timestamp)
      const startTs = Date.now() + 200; // small cushion
      channel.postMessage({ type: "start", startTs, text: TEXT });
      beginRace(startTs);
    }, 1000);
  }

  // ---------- Practice mode ----------
  function beginPractice() {
    leaveLobby(); // ensures clean state + no lobby
    mode = "practice";
    setButtons();

    // show ghost based on best WPM
    const best = getBestWpm();
    ghostName.textContent = best > 0 ? `Your Best (${best} wpm)` : "Your Best (set one)";
    oppName.textContent = "Opponent (multiplayer)";

    finished = false;
    startedAt = performance.now();
    youCorrect = 0; youTotal = 0;
    ghostCorrect = 0;
    paceCorrect = 0;

    resetTrack();
    updateStats();

    input.disabled = false;
    input.value = "";
    input.focus();

    setLobbyStatus("Practice mode. You vs. yourself.");
    requestAnimationFrame(tickPractice);
  }

  function tickPractice(ts) {
    if (mode !== "practice" || finished) return;

    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;

    // Ghost: pace based on best WPM (chars/sec = (wpm*5)/60)
    const best = getBestWpm();
    if (best > 0) {
      const cps = (best * 5) / 60;
      ghostCorrect = Math.min(TEXT.length, Math.floor(cps * seconds));
      setRunner(rGhost, charsDoneToProgress(ghostCorrect));
    } else {
      setRunner(rGhost, 0);
    }

    // Pace line: gentle baseline (25 wpm)
    const paceWpm = 25;
    const paceCps = (paceWpm * 5) / 60;
    paceCorrect = Math.min(TEXT.length, Math.floor(paceCps * seconds));
    setRunner(rLine, charsDoneToProgress(paceCorrect));

    // Opponent lane stays still in practice
    setRunner(rOpp, 0);

    updateStats();

    if (charsDoneToProgress(youCorrect) >= 1) {
      finishRace();
      return;
    }

    requestAnimationFrame(tickPractice);
  }

  // ---------- Multiplayer race ----------
  function beginRace(startTs) {
    mode = "race";
    setButtons();

    stopCountdown();

    finished = false;
    youCorrect = 0; youTotal = 0;
    oppCorrect = 0;

    resetTrack();
    updateStats();

    input.disabled = true;
    input.value = "";

    const delay = Math.max(0, startTs - Date.now());
    setLobbyStatus(`Race starting…`);
    setTimeout(() => {
      if (mode !== "race") return;
      startedAt = performance.now();
      input.disabled = false;
      input.focus();
      setLobbyStatus("Race started. Type now.");
      requestAnimationFrame(tickRace);
    }, delay);
  }

  function tickRace(ts) {
    if (mode !== "race" || finished) return;

    // opponent position is driven by messages
    setRunner(rOpp, charsDoneToProgress(oppCorrect));

    // ghost/pace still helpful even in multiplayer
    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;
    const best = getBestWpm();
    if (best > 0) {
      const cps = (best * 5) / 60;
      ghostCorrect = Math.min(TEXT.length, Math.floor(cps * seconds));
      setRunner(rGhost, charsDoneToProgress(ghostCorrect));
    } else {
      setRunner(rGhost, 0);
    }
    const paceWpm = 25;
    const paceCps = (paceWpm * 5) / 60;
    paceCorrect = Math.min(TEXT.length, Math.floor(paceCps * seconds));
    setRunner(rLine, charsDoneToProgress(paceCorrect));

    updateStats();

    if (charsDoneToProgress(youCorrect) >= 1) {
      finishRace();
      return;
    }

    requestAnimationFrame(tickRace);
  }

  function finishRace(){
    finished = true;
    input.disabled = true;

    const seconds = startedAt ? (performance.now() - startedAt) / 1000 : 0;
    const finalWpm = calcWPM(youCorrect, seconds);
    const best = getBestWpm();
    if (finalWpm > best) setBestWpm(finalWpm);

    if (mode === "practice") {
      setLobbyStatus(`Practice finished. WPM: ${finalWpm}. Click New Race to practice again.`);
    } else if (mode === "race") {
      setLobbyStatus(`Finished. WPM: ${finalWpm}. Click New Race to re-queue.`);
      // stay in lobby for rematch? keep simple: leave, re-queue on New Race
      leaveLobby();
      mode = "idle";
      setButtons();
    }
  }

  // ---------- Input ----------
  input.addEventListener("input", () => {
    if (!startedAt || finished) return;

    const typed = input.value;
    youTotal = typed.length;
    youCorrect = computeCorrectChars(typed);

    setRunner(rYou, charsDoneToProgress(youCorrect));
    updateStats();

    if (mode === "race" && inLobby) {
      channel.postMessage({ type: "progress", id: myId, correct: youCorrect, ts: Date.now() });
    }

    if (typed.length > TEXT.length) {
      input.value = typed.slice(0, TEXT.length);
    }
  });

  // ---------- BroadcastChannel messages ----------
  channel.onmessage = (ev) => {
    const msg = ev.data || {};

    if (msg.type === "join") {
      lobby.set(msg.id, { name: msg.name, ts: msg.ts || Date.now() });
      renderLobby();
      startCountdownIfReady();
    }

    if (msg.type === "leave") {
      lobby.delete(msg.id);
      renderLobby();

      // If someone leaves, cancel countdown/race start conditions
      if (mode === "lobby") startCountdownIfReady();
      if (mode === "race" && realPlayersCount() < 2) {
        finished = true;
        input.disabled = true;
        setLobbyStatus("Opponent left. Race cancelled.");
        leaveLobby();
      }
    }

    if (msg.type === "sync" && inLobby) {
      channel.postMessage({
        type: "roster",
        to: msg.from,
        roster: Array.from(lobby.entries()).map(([id, v]) => [id, v.name, v.ts])
      });
    }

    if (msg.type === "roster" && msg.to === myId) {
      msg.roster.forEach(([id, name, ts]) => {
        lobby.set(id, { name, ts: ts || Date.now() });
      });
      renderLobby();
      startCountdownIfReady();
    }

    if (msg.type === "countdown" && mode === "lobby") {
      const count = realPlayersCount();
      if (count < 2) return; // ignore if not actually ready
      countdown = Number(msg.seconds || 0);
      if (countdown > 0) {
        setLobbyStatus(`Match found. Race starts in ${countdown}s…`);
      }
    }

    if (msg.type === "start") {
      // If I'm in lobby and have >=2 players, start
      if (mode === "lobby" && realPlayersCount() >= 2) {
        beginRace(msg.startTs);
      }
    }

    if (msg.type === "progress") {
      if (mode !== "race") return;
      if (msg.id === myId) return;
      oppCorrect = Math.max(0, Number(msg.correct || 0));
      const name = lobby.get(msg.id)?.name;
      if (name) oppName.textContent = name;
    }
  };

  // ---------- Buttons ----------
  btnEnter.addEventListener("click", () => {
    joinLobby();
    startCountdownIfReady();
  });

  btnPractice.addEventListener("click", () => {
    beginPractice();
  });

  btnLeave.addEventListener("click", () => {
    leaveLobby();
  });

  btnNew.addEventListener("click", () => {
    // In practice: restart practice. In race/idle: re-queue.
    if (mode === "practice") {
      beginPractice();
      return;
    }
    leaveLobby();
    joinLobby();
    startCountdownIfReady();
  });

  window.addEventListener("beforeunload", () => {
    if (inLobby) channel.postMessage({ type: "leave", id: myId });
  });

  // init
  resetTrack();
  renderLobby();
  setButtons();
})();
</script>
</body>
</html>
