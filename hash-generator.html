<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Hash Generator | surewhynot.app</title>
  <meta name="description" content="Privacy-forward hash generator that runs locally. SHA-256/384/512 digests, HMAC, PBKDF2, HKDF. Text + file hashing, copy + verify." />
  <link rel="canonical" href="https://surewhynot.app/hash-generator.html" />

  <meta property="og:title" content="Hash Generator | surewhynot.app" />
  <meta property="og:description" content="Local hashing: SHA-2 digest, HMAC, PBKDF2, HKDF. No uploads, no tracking." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://surewhynot.app/hash-generator.html" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Hash Generator | surewhynot.app" />
  <meta name="twitter:description" content="Local hashing: SHA-2 digest, HMAC, PBKDF2, HKDF. No uploads, no tracking." />

  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; base-uri 'none'; form-action 'none';
                 connect-src 'self';
                 img-src 'self' data:;
                 style-src 'self';
                 script-src 'self' 'unsafe-inline' blob:;
                 worker-src 'self' blob:;
                 frame-ancestors 'none'; upgrade-insecure-requests" />
  <meta name="referrer" content="no-referrer" />

  <link rel="stylesheet" href="/assets/site.css">
</head>

<script>
async function loadPartials() {
  const header = await fetch('/partials/header.html');
  const footer = await fetch('/partials/footer.html');
  document.getElementById('site-header').innerHTML = await header.text();
  document.getElementById('site-footer').innerHTML = await footer.text();
}
loadPartials();
</script>

<body>
  <div class="page">
    <div id="site-header"></div>

    <main>
      <div class="wrap">
        <section class="grid">

          <div class="card">
            <div class="pad">
              <div class="h1">Hash Generator</div>
              <div class="muted">Runs locally in your browser. No network calls.</div>

              <div style="margin-top:14px">
                <label class="muted" style="display:block;margin-bottom:6px">Mode</label>
                <select id="mode">
                  <option value="digest">Digest (SHA-2)</option>
                  <option value="hmac">HMAC (SHA-2)</option>
                  <option value="hkdf">HKDF (SHA-2)</option>
                  <option value="pbkdf2">PBKDF2 (SHA-2)</option>
                </select>
              </div>

              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
                <div style="flex:1;min-width:220px">
                  <label class="muted" style="display:block;margin-bottom:6px">Algorithm</label>
                  <select id="algo">
                    <option value="SHA-256">SHA-256</option>
                    <option value="SHA-384">SHA-384</option>
                    <option value="SHA-512">SHA-512</option>
                  </select>
                </div>
                <div style="flex:1;min-width:220px">
                  <label class="muted" style="display:block;margin-bottom:6px">Output</label>
                  <select id="enc">
                    <option value="hex">hex</option>
                    <option value="base64">base64</option>
                    <option value="base64url">base64url</option>
                  </select>
                </div>
              </div>

              <div id="hmacBlock" style="display:none;margin-top:10px">
                <label class="muted" style="display:block;margin-bottom:6px">HMAC key (utf-8)</label>
                <input id="hmacKey" placeholder="key material..." autocomplete="off" />
              </div>

              <div id="hkdfBlock" style="display:none;margin-top:10px">
                <label class="muted" style="display:block;margin-bottom:6px">HKDF IKM (utf-8)</label>
                <input id="hkdfIkm" placeholder="ikm..." autocomplete="off" />
                <label class="muted" style="display:block;margin:10px 0 6px">Salt (optional)</label>
                <input id="hkdfSalt" placeholder="salt..." autocomplete="off" />
                <label class="muted" style="display:block;margin:10px 0 6px">Info (optional)</label>
                <input id="hkdfInfo" placeholder="context/info..." autocomplete="off" />
                <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
                  <div style="flex:1;min-width:220px">
                    <label class="muted" style="display:block;margin-bottom:6px">Bits</label>
                    <input id="hkdfBits" type="number" min="128" step="8" value="256" />
                  </div>
                </div>
              </div>

              <div id="pbkdf2Block" style="display:none;margin-top:10px">
                <label class="muted" style="display:block;margin-bottom:6px">Salt (utf-8)</label>
                <input id="salt" placeholder="salt..." autocomplete="off" />
                <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
                  <div style="flex:1;min-width:220px">
                    <label class="muted" style="display:block;margin-bottom:6px">Iterations</label>
                    <input id="iters" type="number" min="1" step="1" value="310000" />
                  </div>
                  <div style="flex:1;min-width:220px">
                    <label class="muted" style="display:block;margin-bottom:6px">Bits</label>
                    <input id="bits" type="number" min="128" step="8" value="256" />
                  </div>
                </div>
              </div>

              <div style="margin-top:12px">
                <label class="muted" style="display:block;margin-bottom:6px">Text input</label>
                <textarea id="text" placeholder="paste text here..." style="width:100%;min-height:160px"></textarea>
              </div>

              <div style="margin-top:12px">
                <label class="muted" style="display:block;margin-bottom:6px">File input (Digest/HMAC only)</label>
                <input id="file" type="file" />
                <div class="muted" style="margin-top:6px">File is read into memory (cap enforced).</div>
              </div>

              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
                <button id="hashBtn">Hash</button>
                <button id="clearBtn">Clear</button>
              </div>

              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
                <div style="flex:1;min-width:220px">
                  <label class="muted" style="display:block;margin-bottom:6px">Max text bytes</label>
                  <input id="maxTextBytes" type="number" min="1024" step="1024" value="2000000" />
                </div>
                <div style="flex:1;min-width:220px">
                  <label class="muted" style="display:block;margin-bottom:6px">Max file bytes</label>
                  <input id="maxFileBytes" type="number" min="1048576" step="1048576" value="50000000" />
                </div>
              </div>

            </div>
          </div>

          <div class="card">
            <div class="pad">
              <div class="h1">Result</div>

              <div id="out" style="margin-top:10px;border:1px solid rgba(255,255,255,.12);padding:12px;border-radius:12px;word-break:break-all;min-height:86px"></div>

              <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px">
                <button id="copyBtn" disabled>Copy</button>
                <button id="verifyBtn" disabled>Verify</button>
              </div>

              <div style="margin-top:12px">
                <label class="muted" style="display:block;margin-bottom:6px">Verify against expected</label>
                <input id="expected" placeholder="paste expected hash..." autocomplete="off" />
                <div id="verdict" class="muted" style="margin-top:8px"></div>
              </div>

              <div style="margin-top:14px">
                <label class="muted" style="display:block;margin-bottom:6px">Progress</label>
                <progress id="prog" max="1" value="0" style="width:100%"></progress>
                <div id="status" class="muted" style="margin-top:8px"></div>
              </div>

            </div>
          </div>

        </section>
      </div>
    </main>

    <div id="site-footer"></div>
  </div>

  <script>
    (() => {
      "use strict";

      const workerSrc = `
        "use strict";
        const te = new TextEncoder();

        function b64(bytes) {
          let s = "";
          const chunk = 0x8000;
          for (let i = 0; i < bytes.length; i += chunk) s += String.fromCharCode(...bytes.subarray(i, i + chunk));
          return btoa(s);
        }
        function toHex(bytes) {
          let out = "";
          for (let i = 0; i < bytes.length; i++) out += bytes[i].toString(16).padStart(2, "0");
          return out;
        }
        function toBase64Url(b64str) { return b64str.replace(/\\+/g,"-").replace(/\\//g,"_").replace(/=+$/g,""); }
        function encodeOut(bytes, enc) {
          if (enc === "hex") return toHex(bytes);
          const b = b64(bytes);
          if (enc === "base64") return b;
          return toBase64Url(b);
        }

        async function digestBytes(algo, bytes) {
          const buf = await crypto.subtle.digest(algo, bytes);
          return new Uint8Array(buf);
        }
        async function hmacBytes(hashAlgo, keyStr, bytes) {
          const key = await crypto.subtle.importKey("raw", te.encode(keyStr), { name:"HMAC", hash:{ name:hashAlgo } }, false, ["sign"]);
          const sig = await crypto.subtle.sign("HMAC", key, bytes);
          return new Uint8Array(sig);
        }
        async function pbkdf2Bytes(hashAlgo, passwordStr, saltStr, iterations, bits) {
          const baseKey = await crypto.subtle.importKey("raw", te.encode(passwordStr), "PBKDF2", false, ["deriveBits"]);
          const derived = await crypto.subtle.deriveBits({ name:"PBKDF2", hash:hashAlgo, salt:te.encode(saltStr), iterations }, baseKey, bits);
          return new Uint8Array(derived);
        }
        async function hkdfBytes(hashAlgo, ikmStr, saltStr, infoStr, bits) {
          const ikmKey = await crypto.subtle.importKey("raw", te.encode(ikmStr), "HKDF", false, ["deriveBits"]);
          const derived = await crypto.subtle.deriveBits({ name:"HKDF", hash:hashAlgo, salt:te.encode(saltStr||""), info:te.encode(infoStr||"") }, ikmKey, bits);
          return new Uint8Array(derived);
        }

        self.onmessage = async (e) => {
          const msg = e.data;
          try {
            if (msg.type !== "hash") return;

            const { mode, algo, enc, textBytes, fileBytes, hmacKey, pbkdf2Salt, pbkdf2Iters, pbkdf2Bits, hkdfIkm, hkdfSalt, hkdfInfo, hkdfBits } = msg;

            let combined;
            if (textBytes && fileBytes) {
              combined = new Uint8Array(textBytes.length + 1 + fileBytes.length);
              combined.set(textBytes, 0);
              combined[textBytes.length] = 0x0A;
              combined.set(fileBytes, textBytes.length + 1);
            } else if (fileBytes) {
              combined = fileBytes;
            } else {
              combined = textBytes || new Uint8Array();
            }

            let outBytes;
            if (mode === "digest") outBytes = await digestBytes(algo, combined);
            else if (mode === "hmac") outBytes = await hmacBytes(algo, hmacKey || "", combined);
            else if (mode === "pbkdf2") {
              const password = new TextDecoder().decode(textBytes || new Uint8Array());
              outBytes = await pbkdf2Bytes(algo, password, pbkdf2Salt || "", pbkdf2Iters, pbkdf2Bits);
            } else if (mode === "hkdf") {
              outBytes = await hkdfBytes(algo, hkdfIkm || "", hkdfSalt || "", hkdfInfo || "", hkdfBits);
            } else throw new Error("Unknown mode");

            self.postMessage({ type:"result", value: encodeOut(outBytes, enc) });
          } catch (err) {
            self.postMessage({ type:"error", message: String(err && err.message ? err.message : err) });
          }
        };
      `;

      const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], { type: "text/javascript" })));
      const $ = (id) => document.getElementById(id);
      const te = new TextEncoder();

      const modeEl = $("mode"), algoEl = $("algo"), encEl = $("enc");
      const hmacBlock = $("hmacBlock"), pbkdf2Block = $("pbkdf2Block"), hkdfBlock = $("hkdfBlock");
      const textEl = $("text"), fileEl = $("file");
      const hashBtn = $("hashBtn"), clearBtn = $("clearBtn"), copyBtn = $("copyBtn"), verifyBtn = $("verifyBtn");
      const outEl = $("out"), expectedEl = $("expected"), verdictEl = $("verdict");
      const progEl = $("prog"), statusEl = $("status");
      const maxTextBytesEl = $("maxTextBytes"), maxFileBytesEl = $("maxFileBytes");

      const hmacKeyEl = $("hmacKey");
      const saltEl = $("salt"), itersEl = $("iters"), bitsEl = $("bits");
      const hkdfIkmEl = $("hkdfIkm"), hkdfSaltEl = $("hkdfSalt"), hkdfInfoEl = $("hkdfInfo"), hkdfBitsEl = $("hkdfBits");

      function setStatus(s) { statusEl.textContent = s || ""; }
      function setProgress(v) { progEl.value = Math.max(0, Math.min(1, v)); }
      function clampInt(n, min, max) { n = Math.floor(Number.isFinite(n) ? n : min); return Math.min(max, Math.max(min, n)); }

      function constantTimeEqual(a, b) {
        const aa = te.encode(a), bb = te.encode(b);
        const len = Math.max(aa.length, bb.length);
        let diff = aa.length ^ bb.length;
        for (let i = 0; i < len; i++) diff |= ((aa[i] || 0) ^ (bb[i] || 0));
        return diff === 0;
      }

      function modeChanged() {
        const m = modeEl.value;
        hmacBlock.style.display = (m === "hmac") ? "" : "none";
        pbkdf2Block.style.display = (m === "pbkdf2") ? "" : "none";
        hkdfBlock.style.display = (m === "hkdf") ? "" : "none";
        if (m === "pbkdf2" || m === "hkdf") fileEl.value = "";
        verdictEl.textContent = "";
      }
      modeEl.addEventListener("change", modeChanged);
      modeChanged();

      function getLimits() {
        return {
          maxText: clampInt(parseInt(maxTextBytesEl.value, 10), 1024, 50_000_000),
          maxFile: clampInt(parseInt(maxFileBytesEl.value, 10), 1024 * 1024, 500_000_000)
        };
      }

      function getTextBytes(maxBytes) {
        const bytes = te.encode(textEl.value || "");
        if (bytes.length > maxBytes) throw new Error(`Text too large (${bytes.length} > ${maxBytes})`);
        return bytes;
      }

      async function readFileBytes(file, maxBytes) {
        if (!file) return null;
        if (file.size > maxBytes) throw new Error(`File too large (${file.size} > ${maxBytes})`);
        setStatus("Reading file…");
        setProgress(0.15);
        const buf = await file.arrayBuffer();
        setProgress(0.35);
        return new Uint8Array(buf);
      }

      function requestHash(payload) {
        return new Promise((resolve, reject) => {
          const onMsg = (e) => {
            const msg = e.data;
            if (msg.type === "result") { worker.removeEventListener("message", onMsg); resolve(msg.value); }
            else if (msg.type === "error") { worker.removeEventListener("message", onMsg); reject(new Error(msg.message)); }
          };
          worker.addEventListener("message", onMsg);
          worker.postMessage(payload);
        });
      }

      async function doHash() {
        outEl.textContent = "";
        verdictEl.textContent = "";
        setProgress(0);
        setStatus("");

        try {
          const { maxText, maxFile } = getLimits();
          const mode = modeEl.value, algo = algoEl.value, enc = encEl.value;
          const file = fileEl.files && fileEl.files[0] ? fileEl.files[0] : null;

          setStatus("Encoding text…");
          setProgress(0.05);

          let textBytes = null, fileBytes = null;
          if (mode === "pbkdf2" || mode === "hkdf") textBytes = getTextBytes(maxText);
          else {
            textBytes = (textEl.value && textEl.value.length) ? getTextBytes(maxText) : new Uint8Array();
            fileBytes = file ? await readFileBytes(file, maxFile) : null;
          }

          setStatus("Hashing…");
          setProgress(0.6);

          const pbkdf2Iters = clampInt(parseInt(itersEl?.value || "310000", 10), 1, 10_000_000);
          const pbkdf2Bits  = clampInt(parseInt(bitsEl?.value  || "256", 10), 128, 4096);
          const hkdfBits    = clampInt(parseInt(hkdfBitsEl?.value || "256", 10), 128, 4096);

          const value = await requestHash({
            type: "hash",
            mode, algo, enc,
            textBytes, fileBytes,
            hmacKey: hmacKeyEl?.value || "",
            pbkdf2Salt: saltEl?.value || "",
            pbkdf2Iters, pbkdf2Bits,
            hkdfIkm: hkdfIkmEl?.value || "",
            hkdfSalt: hkdfSaltEl?.value || "",
            hkdfInfo: hkdfInfoEl?.value || "",
            hkdfBits
          });

          outEl.textContent = value;
          copyBtn.disabled = false;
          verifyBtn.disabled = false;
          setProgress(1);
          setStatus("Done.");
        } catch (e) {
          setProgress(0);
          setStatus(String(e && e.message ? e.message : e));
          copyBtn.disabled = true;
          verifyBtn.disabled = true;
        }
      }

      hashBtn.addEventListener("click", doHash);

      clearBtn.addEventListener("click", () => {
        textEl.value = "";
        fileEl.value = "";
        if (hmacKeyEl) hmacKeyEl.value = "";
        if (saltEl) saltEl.value = "";
        if (hkdfIkmEl) hkdfIkmEl.value = "";
        if (hkdfSaltEl) hkdfSaltEl.value = "";
        if (hkdfInfoEl) hkdfInfoEl.value = "";
        outEl.textContent = "";
        expectedEl.value = "";
        verdictEl.textContent = "";
        setProgress(0);
        setStatus("");
        copyBtn.disabled = true;
        verifyBtn.disabled = true;
      });

      copyBtn.addEventListener("click", async () => {
        const v = outEl.textContent || "";
        if (!v) return;
        await navigator.clipboard.writeText(v);
        setStatus("Copied.");
      });

      verifyBtn.addEventListener("click", () => {
        const got = (outEl.textContent || "").trim();
        const exp = (expectedEl.value || "").trim();
        if (!got || !exp) { verdictEl.textContent = ""; return; }
        verdictEl.textContent = constantTimeEqual(got, exp) ? "MATCH" : "NO MATCH";
      });
    })();
  </script>
</body>
</html>
