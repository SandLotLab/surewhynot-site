<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roguelike | surewhynot.app</title>

  <!-- SEO -->
  <meta name="description" content="Top-down browser roguelike with 51 beatable levels (0–50). Difficulty scales by tier and sub-level. Best moves/time saved locally per level." />
  <meta name="robots" content="index,follow" />
  <link rel="canonical" href="https://surewhynot.app/roguelike" />
  <meta property="og:title" content="Roguelike | surewhynot.app" />
  <meta property="og:description" content="51 beatable levels (0–50). Enemy scaling. Touch swipe controls. Best moves/time saved locally per level." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://surewhynot.app/roguelike" />

  <!-- Google AdSense -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7167291111213614"
    crossorigin="anonymous"></script>

  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#0b0f14; color:#e6edf3;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    }
    .wrap{ width:min(1020px,96vw); }
    header{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; padding:10px 0; flex-wrap:wrap; }
    .card{
      border:1px solid #1f2630; background:#0f1620; border-radius:14px; padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    canvas{
      width:100%; height:auto; display:block; border-radius:12px; border:1px solid #1f2630; background:#070a0e;
    }
    .hud{
      display:flex; justify-content:space-between; gap:12px; margin-top:8px;
      font-size:12px; opacity:.88; flex-wrap:wrap; align-items:center;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input{
      background:#0b0f14; color:#e6edf3; border:1px solid #1f2630; border-radius:10px;
      padding:6px 10px; font:inherit; font-size:12px; width:88px;
    }
    .muted{ opacity:.65; }
    .overlay{
      position:absolute; inset:0; display:none; place-items:center;
      background:rgba(0,0,0,.55); border-radius:12px;
    }
    .panel{
      width:min(560px, 92%); border:1px solid #1f2630; background:#0b0f14; border-radius:14px;
      padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.45);
    }
    .h1{ font-weight:700; font-size:14px; }
    .btnrow{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    button{
      cursor:pointer; background:#0f1620; color:#e6edf3; border:1px solid #1f2630; border-radius:12px;
      padding:8px 10px; font:inherit; font-size:12px;
    }
    button:hover{ border-color:#2a3a50; }
  </style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="row">
      <div><b>Roguelike</b></div>
      <span class="muted" style="font-size:12px;">WASD/Arrows • Swipe on canvas • R retry • N next • P prev</span>
    </div>

    <div class="row">
      <label class="muted" for="levelInput">Level</label>
      <input id="levelInput" type="number" min="0" max="50" step="1" value="0" />
      <button id="goBtn">Go</button>
      <button id="resetBestBtn" title="Clears best stats for this level only">Reset Best</button>
    </div>
  </header>

  <div class="card">
    <div style="position:relative;">
      <canvas id="game" width="768" height="512"></canvas>

      <div id="overlay" class="overlay">
        <div class="panel">
          <div class="h1" id="overlayTitle">Level Complete</div>
          <div class="muted" id="overlayBody" style="margin-top:8px; line-height:1.6;"></div>
          <div class="btnrow">
            <button id="nextBtn">Next (N)</button>
            <button id="retryBtn">Retry (R)</button>
            <button id="closeBtn">Close</button>
          </div>
        </div>
      </div>
    </div>

    <div class="hud">
      <div class="row">
        <div>Level: <b id="lvlLabel">0</b></div>
        <div class="muted" id="tierLabel">—</div>
        <div>Enemies: <b id="enemyLabel">0</b></div>
        <div class="muted">Goal: reach green</div>
      </div>

      <div class="row">
        <div>Moves (run): <b id="movesRun">0</b></div>
        <div>Time (run): <b id="timeRun">0.0s</b></div>
        <div class="muted">Best: <b id="bestLabel">—</b></div>
      </div>

      <div class="row">
        <div>Status: <b id="status">Ready</b></div>
      </div>
    </div>

    <ins class="adsbygoogle"
         style="display:block;margin-top:12px"
         data-ad-client="ca-pub-7167291111213614"
         data-ad-slot="auto"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>(adsbygoogle=window.adsbygoogle||[]).push({});</script>
  </div>
</div>

<script>
"use strict";

/* GUARANTEE:
   Every level is BEATABLE:
   - Generate map
   - Place player + exit
   - Compute a shortest path (player->exit)
   - Place enemies so that along that path, enemies cannot reach any tile fast enough to catch,
     given this level's enemy speed (steps per player move) + a tier-tuned safety margin.
   This guarantees at least one winning strategy: follow the safe path.
*/

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });

const statusEl   = document.getElementById("status");
const lvlLabel   = document.getElementById("lvlLabel");
const tierLabel  = document.getElementById("tierLabel");
const enemyLabel = document.getElementById("enemyLabel");
const movesRunEl = document.getElementById("movesRun");
const timeRunEl  = document.getElementById("timeRun");
const bestLabel  = document.getElementById("bestLabel");
const levelInput = document.getElementById("levelInput");
const goBtn      = document.getElementById("goBtn");
const resetBestBtn = document.getElementById("resetBestBtn");

const overlay = document.getElementById("overlay");
const overlayTitle = document.getElementById("overlayTitle");
const overlayBody = document.getElementById("overlayBody");
const nextBtn = document.getElementById("nextBtn");
const retryBtn = document.getElementById("retryBtn");
const closeBtn = document.getElementById("closeBtn");

const TILE = 16;
const W = Math.floor(canvas.width / TILE);
const H = Math.floor(canvas.height / TILE);

const WALL = 0, FLOOR = 1;

let level = 0;
let seed, rng;
let map = [];
let player = {x:0,y:0};
let exit = {x:0,y:0};
let enemies = [];
let safePath = []; // array of {x,y} including start->exit

let alive = true;
let won = false;

let moves = 0;
let startMs = 0;
let running = false;

// ---------- RNG ----------
function makeSeed() {
  return "run-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
}
function hash32(str) {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(a) {
  return function() {
    let t = (a += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function randi(min, maxIncl) { return Math.floor(rng() * (maxIncl - min + 1)) + min; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ---------- Level naming (category + sub every 2 levels) ----------
const SUB = ["Low","Medium","Average","Hard","Insane"];

function categoryName(lv){
  if (lv <= 9) return "Easiest";
  if (lv <= 19) return "Easy";
  if (lv <= 29) return "Medium";
  if (lv <= 39) return "Hard";
  if (lv <= 49) return "Insane";
  return "You will not survive";
}

function subName(lv){
  if (lv === 50) return "";
  const within10 = lv % 10;          // 0..9
  const idx = Math.floor(within10/2); // 0..4
  return SUB[idx];
}

// Difficulty params (still beatable)
function paramsForLevel(lv){
  const cat =
    (lv <= 9) ? 0 :
    (lv <= 19) ? 1 :
    (lv <= 29) ? 2 :
    (lv <= 39) ? 3 :
    (lv <= 49) ? 4 : 5;

  // enemy speed capped at 2 to keep "beatable guarantee" realistic in tight corridors
  const enemySteps = (cat <= 2) ? 1 : 2; // Medium and below: 1, Hard+: 2

  // enemies scale slowly; sub-level adds small ramp
  const sub = (lv === 50) ? 4 : Math.floor((lv % 10) / 2); // 0..4
  const baseEnemies = [1,2,3,4,6,8][cat];
  const enemyCount = clamp(baseEnemies + sub + Math.floor(lv/15), 1, 14);

  // required path length grows with level, but kept reasonable
  const minPath = clamp(10 + lv, 10, 50);

  // how much "time advantage" the player must have along the guaranteed safe path
  // smaller margin => harder but still beatable
  const safetyMargin = [6,5,4,3,2,1][cat]; // in "enemy steps" units

  // map complexity
  const roomAttempts = 28 + lv;
  const maxRooms = clamp(12 + Math.floor(lv * 0.40), 12, 30);

  return { enemySteps, enemyCount, minPath, safetyMargin, roomAttempts, maxRooms };
}

// ---------- Map gen (rooms + corridors) ----------
function makeMap(w, h, roomAttempts, maxRooms) {
  const g = Array.from({length:h}, () => Array.from({length:w}, () => WALL));
  const rooms = [];

  for (let i = 0; i < roomAttempts && rooms.length < maxRooms; i++) {
    const rw = randi(4, 12);
    const rh = randi(4, 10);
    const rx = randi(1, w - rw - 2);
    const ry = randi(1, h - rh - 2);

    const room = { x: rx, y: ry, w: rw, h: rh, cx: rx + (rw >> 1), cy: ry + (rh >> 1) };

    let ok = true;
    for (const r of rooms) {
      const pad = 1;
      if (room.x < r.x + r.w + pad &&
          room.x + room.w + pad > r.x &&
          room.y < r.y + r.h + pad &&
          room.y + room.h + pad > r.y) {
        ok = false; break;
      }
    }
    if (!ok) continue;

    carveRoom(g, room);
    if (rooms.length) connectRooms(g, rooms[rooms.length - 1], room);
    rooms.push(room);
  }

  if (!rooms.length) carveRoom(g, {x:2,y:2,w:w-4,h:h-4});
  return g;
}

function carveRoom(g, r){
  for (let y=r.y; y<r.y+r.h; y++)
    for (let x=r.x; x<r.x+r.w; x++)
      g[y][x]=FLOOR;
}

function connectRooms(g, a, b){
  let x=a.cx, y=a.cy;
  const tx=b.cx, ty=b.cy;

  if (rng()<0.5){
    while (x!==tx){ x += x<tx?1:-1; g[y][x]=FLOOR; }
    while (y!==ty){ y += y<ty?1:-1; g[y][x]=FLOOR; }
  } else {
    while (y!==ty){ y += y<ty?1:-1; g[y][x]=FLOOR; }
    while (x!==tx){ x += x<tx?1:-1; g[y][x]=FLOOR; }
  }
}

function isFloor(x,y){ return x>=0 && y>=0 && x<W && y<H && map[y][x]===FLOOR; }

// ---------- BFS utilities ----------
function bfsWithParents(start){
  const dist = new Int16Array(W*H);
  dist.fill(-1);
  const parent = new Int32Array(W*H);
  parent.fill(-1);

  const qx = new Int16Array(W*H);
  const qy = new Int16Array(W*H);
  let qs=0, qe=0;

  dist[start.y*W + start.x] = 0;
  qx[qe]=start.x; qy[qe]=start.y; qe++;

  while (qs<qe){
    const x=qx[qs], y=qy[qs]; qs++;
    const d=dist[y*W + x];

    const nbr = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for (const [nx,ny] of nbr){
      if (!isFloor(nx,ny)) continue;
      const idx=ny*W + nx;
      if (dist[idx]!==-1) continue;
      dist[idx]=d+1;
      parent[idx]=y*W + x;
      qx[qe]=nx; qy[qe]=ny; qe++;
    }
  }
  return {dist, parent};
}

function reconstructPath(parent, start, goal){
  const path = [];
  const startIdx = start.y*W + start.x;
  let cur = goal.y*W + goal.x;
  if (parent[cur] === -1 && cur !== startIdx) return null;
  while (cur !== -1){
    const x = cur % W;
    const y = (cur / W) | 0;
    path.push({x,y});
    if (cur === startIdx) break;
    cur = parent[cur];
  }
  path.reverse();
  return path;
}

function bfsDistance(start){
  const {dist} = bfsWithParents(start);
  return dist;
}

// ---------- Placement helpers ----------
function placeOnFloor(){
  for (let i=0;i<20000;i++){
    const x=randi(1,W-2), y=randi(1,H-2);
    if (isFloor(x,y)) return {x,y};
  }
  map[2][2]=FLOOR; return {x:2,y:2};
}
function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
function samePos(a,b){ return a.x===b.x && a.y===b.y; }

function pickExitWithMinPath(pl, minPath){
  const {dist, parent} = bfsWithParents(pl);
  // try many random floors; accept one with dist >= minPath
  for (let i=0;i<30000;i++){
    const ex = placeOnFloor();
    const d = dist[ex.y*W + ex.x];
    if (d >= minPath) {
      const path = reconstructPath(parent, pl, ex);
      if (path && path.length-1 === d) return {ex, path, distFromPlayer: dist};
    }
  }
  return null;
}

// SAFE PATH CONDITION:
// For each tile on the chosen safe path at player step k,
// every enemy must have distance_to_tile > (k * enemySteps + safetyMargin).
function safeAgainstAllEnemies(path, enemyStarts, enemySteps, safetyMargin){
  // Precompute k step index for each tile on path
  // path[0] is start at k=0
  for (const e of enemyStarts){
    const distE = bfsDistance(e);
    for (let k=0; k<path.length; k++){
      const t = path[k];
      const dE = distE[t.y*W + t.x];
      if (dE === -1) continue; // disconnected from enemy = safe
      const enemyBudget = k * enemySteps + safetyMargin;
      if (dE <= enemyBudget) return false;
    }
  }
  return true;
}

function spawnEnemiesBeatable(path, playerStart, exitPos, enemyCount, enemySteps, safetyMargin){
  const enemies = [];
  let tries = 0;

  while (enemies.length < enemyCount && tries < 80000){
    tries++;
    const e = placeOnFloor();

    if (samePos(e, playerStart) || samePos(e, exitPos)) continue;
    if (manhattan(e, playerStart) < 8) continue;
    if (manhattan(e, exitPos) < 6) continue;

    // keep enemies off the safe path (so the guaranteed route stays open)
    let onPath = false;
    for (let i=0; i<path.length; i++){
      if (path[i].x===e.x && path[i].y===e.y) { onPath=true; break; }
    }
    if (onPath) continue;

    // no duplicates
    let clash=false;
    for (const x of enemies){ if (samePos(x,e)) { clash=true; break; } }
    if (clash) continue;

    // check safe path remains safe with this new enemy added
    const test = enemies.concat([e]);
    if (!safeAgainstAllEnemies(path, test, enemySteps, safetyMargin)) continue;

    enemies.push(e);
  }

  // If we couldn't place all enemies without breaking beatability,
  // reduce enemy count for THIS level until beatability holds.
  // (Still increasing difficulty overall, but never "unwinnable".)
  return enemies;
}

// ---------- Build a BEATABLE level ----------
function buildBeatableLevel(lv){
  const p = paramsForLevel(lv);

  for (let attempt=0; attempt<140; attempt++){
    map = makeMap(W, H, p.roomAttempts, p.maxRooms);

    const pl = placeOnFloor();
    const pick = pickExitWithMinPath(pl, p.minPath);
    if (!pick) continue;

    const ex = pick.ex;
    const path = pick.path;

    // place enemies while preserving safe path guarantee
    const ens = spawnEnemiesBeatable(path, pl, ex, p.enemyCount, p.enemySteps, p.safetyMargin);
    if (ens.length < Math.max(1, Math.min(ens.length, p.enemyCount)) && p.enemyCount > 1) {
      // fine — difficulty is enforced by "never unwinnable"
    }

    // final safety check (paranoia)
    if (!safeAgainstAllEnemies(path, ens, p.enemySteps, p.safetyMargin)) continue;

    player = pl;
    exit = ex;
    enemies = ens;
    safePath = path;
    return true;
  }

  // fallback open arena, still beatable (enemies will be forced far)
  map = Array.from({length:H}, ()=>Array.from({length:W}, ()=>FLOOR));
  for (let y=0;y<H;y++){ map[y][0]=WALL; map[y][W-1]=WALL; }
  for (let x=0;x<W;x++){ map[0][x]=WALL; map[H-1][x]=WALL; }

  player = {x:2,y:2};
  exit = {x:W-3,y:H-3};

  const path = [];
  for (let x=2;x<=W-3;x++) path.push({x,y:2});
  for (let y=3;y<=H-3;y++) path.push({x:W-3,y});

  const p2 = paramsForLevel(lv);
  enemies = spawnEnemiesBeatable(path, player, exit, p2.enemyCount, p2.enemySteps, p2.safetyMargin);
  safePath = path;
  return true;
}

// ---------- Best stats (localStorage) ----------
function bestKey(lv){ return "swyn_roguelike_best_v2_" + lv; }

function loadBest(lv){
  try{
    const raw = localStorage.getItem(bestKey(lv));
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (!obj || typeof obj.moves!=="number" || typeof obj.ms!=="number") return null;
    return obj;
  } catch { return null; }
}

function saveBest(lv, ms, moves){
  const cur = loadBest(lv);
  const better = (!cur) || (ms < cur.ms) || (ms === cur.ms && moves < cur.moves);
  if (!better) return false;
  try{
    localStorage.setItem(bestKey(lv), JSON.stringify({ms, moves}));
    return true;
  } catch { return false; }
}

function formatBest(obj){
  if (!obj) return "—";
  return `${obj.moves} moves • ${(obj.ms/1000).toFixed(1)}s`;
}

// ---------- Game ----------
function setLevel(lv){
  level = clamp(lv|0, 0, 50);
  levelInput.value = String(level);

  seed = makeSeed();
  rng = mulberry32(hash32(seed)); // internal only (no need to show)

  alive = true; won = false;
  moves = 0; running = false; startMs = 0;

  buildBeatableLevel(level);

  lvlLabel.textContent = String(level);
  const cat = categoryName(level);
  const sub = subName(level);
  tierLabel.textContent = (level === 50)
    ? `• ${cat}`
    : `• ${cat} • ${sub}`;

  enemyLabel.textContent = String(enemies.length);

  movesRunEl.textContent = "0";
  timeRunEl.textContent = "0.0s";
  bestLabel.textContent = formatBest(loadBest(level));

  statusEl.textContent = "Ready";
  hideOverlay();
  draw();
}

function nowMs(){ return performance.now(); }
function startTimerIfNeeded(){ if (!running){ running=true; startMs=nowMs(); } }
function elapsedMs(){ return running ? Math.max(0, nowMs()-startMs) : 0; }

function tryMove(dx,dy){
  if (!alive || won) return;

  const nx = clamp(player.x + dx, 0, W-1);
  const ny = clamp(player.y + dy, 0, H-1);
  if (!isFloor(nx,ny)) return;

  startTimerIfNeeded();

  player.x = nx; player.y = ny;
  moves++;
  movesRunEl.textContent = String(moves);
  timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";

  if (player.x===exit.x && player.y===exit.y){
    won = true;
    onWin();
    draw();
    return;
  }

  enemyTurn();
  checkLose();
  timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";
  draw();
}

function checkLose(){
  for (const e of enemies){
    if (e.x===player.x && e.y===player.y){
      alive = false;
      statusEl.textContent = `Dead • ${moves} moves • ${(elapsedMs()/1000).toFixed(1)}s`;
      showOverlay("You died",
        `Level <b>${level}</b> failed.<br><br>Run: <b>${moves}</b> moves • <b>${(elapsedMs()/1000).toFixed(1)}s</b>`);
      return;
    }
  }
}

function onWin(){
  const ms = elapsedMs();
  const t = (ms/1000).toFixed(1);

  const updated = saveBest(level, ms, moves);
  bestLabel.textContent = formatBest(loadBest(level));

  statusEl.textContent = `Level passed • ${moves} moves • ${t}s`;

  const msg = [
    `Level <b>${level}</b> passed.`,
    `Run: <b>${moves}</b> moves • <b>${t}s</b>`,
    updated ? `<span class="muted">New best saved for this browser.</span>` : `<span class="muted">Best unchanged for this browser.</span>`
  ].join("<br><br>");

  showOverlay("Level Complete", msg);
}

function enemyTurn(){
  const { enemySteps } = paramsForLevel(level);

  for (let step=0; step<enemySteps; step++){
    const distToPlayer = bfsDistance(player);

    for (const e of enemies){
      if (e.x===player.x && e.y===player.y) continue;

      const options = [
        {x:e.x+1,y:e.y},{x:e.x-1,y:e.y},{x:e.x,y:e.y+1},{x:e.x,y:e.y-1}
      ].filter(p => isFloor(p.x,p.y));

      let best = null, bestD = 1e9;
      for (const p of options){
        const d = distToPlayer[p.y*W + p.x];
        if (d === -1) continue;
        if (d < bestD){ bestD=d; best=p; }
      }
      if (!best && options.length) best = options[randi(0, options.length-1)];
      if (best){ e.x=best.x; e.y=best.y; }
    }

    // immediate loss after each enemy step
    for (const e of enemies){
      if (e.x===player.x && e.y===player.y){
        alive = false;
        statusEl.textContent = `Dead • ${moves} moves • ${(elapsedMs()/1000).toFixed(1)}s`;
        showOverlay("You died",
          `Level <b>${level}</b> failed.<br><br>Run: <b>${moves}</b> moves • <b>${(elapsedMs()/1000).toFixed(1)}s</b>`);
        return;
      }
    }
  }
}

// ---------- Render ----------
function draw(){
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      ctx.fillStyle = (map[y][x]===WALL) ? "#0a0f16" : "#121b26";
      ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
    }
  }

  // exit
  ctx.fillStyle = "#39d98a";
  ctx.fillRect(exit.x*TILE+4, exit.y*TILE+4, TILE-8, TILE-8);

  // enemies
  ctx.fillStyle = "#ff4d4d";
  for (const e of enemies){
    ctx.fillRect(e.x*TILE+4, e.y*TILE+4, TILE-8, TILE-8);
  }

  // player
  ctx.fillStyle = "#e6edf3";
  ctx.fillRect(player.x*TILE+3, player.y*TILE+3, TILE-6, TILE-6);

  // HUD text
  ctx.fillStyle = "rgba(255,255,255,0.72)";
  ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText(`Moves: ${moves}`, 10, 16);
  ctx.fillText(`Enemies: ${enemies.length}`, 10, 32);
  ctx.fillText(`Goal: reach green`, 10, 48);

  if (!alive){
    ctx.fillStyle = "rgba(255,77,77,0.85)";
    ctx.fillText(`DEAD`, 10, 64);
  } else if (won){
    ctx.fillStyle = "rgba(57,217,138,0.85)";
    ctx.fillText(`WIN`, 10, 64);
  }
}

// ---------- Overlay ----------
function showOverlay(title, html){
  overlayTitle.textContent = title;
  overlayBody.innerHTML = html;
  overlay.style.display = "grid";
}
function hideOverlay(){ overlay.style.display = "none"; }

// ---------- UI / Keys ----------
function gotoLevelFromInput(){
  const n = Number(levelInput.value);
  if (!Number.isFinite(n)) return;
  setLevel(n|0);
}
goBtn.addEventListener("click", gotoLevelFromInput);
levelInput.addEventListener("keydown", (e)=>{ if (e.key==="Enter") gotoLevelFromInput(); });

resetBestBtn.addEventListener("click", ()=>{
  try { localStorage.removeItem(bestKey(level)); } catch {}
  bestLabel.textContent = "—";
});

nextBtn.addEventListener("click", ()=> setLevel(Math.min(50, level+1)));
retryBtn.addEventListener("click", ()=> setLevel(level));
closeBtn.addEventListener("click", hideOverlay);

addEventListener("keydown", (e)=>{
  const k = e.key.toLowerCase();

  if (k==="n"){ e.preventDefault(); setLevel(Math.min(50, level+1)); return; }
  if (k==="p"){ e.preventDefault(); setLevel(Math.max(0, level-1)); return; }
  if (k==="r"){ e.preventDefault(); setLevel(level); return; }

  const ae = document.activeElement;
  if (ae && (ae.tagName==="INPUT" || ae.tagName==="TEXTAREA")) return;

  if (k==="arrowup" || k==="w"){ e.preventDefault(); tryMove(0,-1); }
  else if (k==="arrowdown" || k==="s"){ e.preventDefault(); tryMove(0,1); }
  else if (k==="arrowleft" || k==="a"){ e.preventDefault(); tryMove(-1,0); }
  else if (k==="arrowright" || k==="d"){ e.preventDefault(); tryMove(1,0); }
});

// update timer display
setInterval(()=>{
  if (running && alive && !won){
    timeRunEl.textContent = (elapsedMs()/1000).toFixed(1) + "s";
  }
}, 100);

// ---------- Touch swipe (tablet/phone) ----------
(() => {
  const el = canvas;
  el.style.touchAction = "none";

  let sx = 0, sy = 0, active = false;

  const THRESH = 22;
  const DOMINANCE = 1.2;

  function onStart(x,y){ sx=x; sy=y; active=true; }
  function onEnd(x,y){
    if (!active) return;
    active=false;

    const dx = x - sx;
    const dy = y - sy;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);

    if (adx < THRESH && ady < THRESH) return;

    if (adx > ady * DOMINANCE){
      if (dx > 0) tryMove(1,0); else tryMove(-1,0);
    } else if (ady > adx * DOMINANCE){
      if (dy > 0) tryMove(0,1); else tryMove(0,-1);
    }
  }

  el.addEventListener("touchstart", (e)=>{
    const t=e.changedTouches[0];
    onStart(t.clientX, t.clientY);
  }, {passive:true});

  el.addEventListener("touchend", (e)=>{
    const t=e.changedTouches[0];
    onEnd(t.clientX, t.clientY);
  }, {passive:true});

  // optional mouse drag swipe too
  el.addEventListener("mousedown", (e)=> onStart(e.clientX, e.clientY));
  addEventListener("mouseup", (e)=> onEnd(e.clientX, e.clientY));
})();

setLevel(0);
</script>
</body>
</html>
