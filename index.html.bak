<!doctype html>
<html lang="en">
<head>
  <!-- Google AdSense -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7167291111213614"
    crossorigin="anonymous"></script>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>surewhynot.app</title>

<link rel="stylesheet" href="/assets/css/style.css">

  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      background:#0b0f14; color:#e8edf5; padding:20px;
    }
    .card{
      width:min(720px,100%);
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:14px;
      padding:16px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
    }
    h1{ margin:0 0 12px; font-size:14px; letter-spacing:.5px; opacity:.95; }
    label{ display:block; font-size:12px; opacity:.85; margin:10px 0 6px; }
    select, textarea{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(0,0,0,0.35);
      color:#e8edf5;
      outline:none;
    }
    textarea{ min-height:90px; resize:vertical; }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:760px){ .row{ grid-template-columns:1fr; } }
    .btns{ display:flex; gap:10px; margin-top:14px; flex-wrap:wrap; }
    button{
      padding:8px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      color:#e8edf5; cursor:pointer;
    }
    button.primary{ border-color: rgba(255,200,80,0.35); }
    button:hover{ background:rgba(255,255,255,0.09); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .out{
      margin-top:14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.30);
      padding:12px;
      white-space:pre-wrap;
      min-height:64px;
    }
    .tiny{ font-size:12px; opacity:.7; margin-top:8px; }
    .hint{ font-size:12px; opacity:.7; margin-top:6px; }
    .micRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:8px; }
    .pill{
      font-size:12px; opacity:.85;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(0,0,0,0.25);
      padding:6px 10px; border-radius:999px;
    }
  </style>
</head>

<body>
  <div class="card">
    <h1>surewhynot.app — monday generator</h1>

    <label>Scenario picker (optional)</label>
    <select id="scenario"></select>
    <div class="hint">Pick a seed, or ignore it and type/speak instead.</div>

    <div class="row">
      <div>
        <label>Tone</label>
        <select id="tone"></select>
        <div class="tiny">Scenario auto-sets tone. You can override.</div>
      </div>
      <div>
        <label>Extra details (optional)</label>
        <textarea id="details" placeholder="Add ingredients. Names, places, weird nouns, whatever."></textarea>
        <div class="tiny">These are treated like background radiation.</div>
      </div>
    </div>

    <label>Generator box (optional — type OR voice fills this)</label>
    <textarea id="prompt" placeholder="Type here… or hit Record and talk."></textarea>

    <div class="micRow">
      <button id="mic" class="primary">Record</button>
      <button id="micStop" disabled>Stop</button>
      <span class="pill" id="micStatus">Mic: idle</span>
      <span class="tiny" id="micNote"></span>
    </div>

    <div class="btns">
      <button class="primary" id="gen">Generate</button>
      <button id="reroll">Reroll</button>
      <button id="copy">Copy</button>
    </div>

    <div class="out" id="output"></div>
    <div class="tiny" id="status"></div>
  </div>

  <footer style="margin-top:20px;font-size:12px;opacity:.7;text-align:center;">
    <a href="/pages/about.html">About</a>
    <a href="/pages/privacy.html">Privacy</a>
    <a href="/pages/contact.html">Contact</a>
  </footer>

<script>
  // ELI5 steps:
  // 1) This page can send text OR recorded audio to your Cloudflare Worker.
  // 2) Text path = JSON POST.
  // 3) Voice path = multipart/form-data POST with an "audio" file.
  // 4) Your Worker transcribes audio, then generates the Monday message.

  const WORKER_URL = "https://broken-violet-bb7d.cloudflare-handprint600.workers.dev/";

  const TONES = [
    "dry",
    "restrained",
    "tired-smart",
    "neutral-but-pointed",
    "calmly-ominous",
    "politely-detached",
    "confident-for-no-reason",
    "low-effort-authority",
    "resigned",
    "unbothered",
    "faintly-disappointed",
    "matter-of-fact-chaos",
    "emotionally-outsourced",
    "deadpan",
    "fake-serious",
    "quietly-judgmental",
    "corporate-ghost",
    "minimalist-threat",
    "post-context",
    "already-processed-this"
  ];

  const SCENARIOS = [
    ["Explain yourself, poorly", "restrained"],
    ["Respond like this is your fault (it isn’t)", "quietly-judgmental"],
    ["Say something that ends the conversation", "deadpan"],
    ["Message written under quiet protest", "emotionally-outsourced"],
    ["Reply that technically answers the question", "neutral-but-pointed"],
    ["A response that implies prior lore", "post-context"],
    ["Text sent from the wrong emotional altitude", "matter-of-fact-chaos"],
    ["Apology with no improvement plan", "fake-serious"],
    ["Confident statement, zero verification", "confident-for-no-reason"],
    ["Explain nothing, clearly", "dry"],
    ["A response that sounds final but isn’t", "restrained"],
    ["Reply like you’ve seen this movie before", "already-processed-this"],
    ["Text that implies an off-screen event", "post-context"],
    ["Respond like you’re late but spiritually on time", "resigned"],
    ["Give an update that creates new questions", "neutral-but-pointed"],
    ["Message that reads like a warning label", "calmly-ominous"],
    ["Reply like you’re conserving oxygen", "low-effort-authority"],
    ["Say less, but worse", "deadpan"],
    ["A polite message with a sharp edge", "politely-detached"],
    ["A calm message that feels threatening", "minimalist-threat"],
    ["Announce something unimportant like it’s a crisis", "matter-of-fact-chaos"],
    ["Deliver a prophecy about something trivial", "calmly-ominous"],
    ["Sound supportive while refusing to help", "politely-detached"],
    ["Explain a decision you didn’t make", "emotionally-outsourced"],
    ["Message that feels pre-approved by nobody", "corporate-ghost"],
    ["Reply like you’re buffering emotionally", "tired-smart"],
    ["Text that implies you’re not surprised", "faintly-disappointed"],
    ["Clarify a misunderstanding you invented", "dry"],
    ["Respond like you just woke up in the timeline", "post-context"],
    ["Apologize like it’s a formality", "corporate-ghost"],
    ["Apologize like it’s a performance review", "quietly-judgmental"],
    ["Sound confident while admitting nothing", "confident-for-no-reason"],
    ["Make peace with the outcome, immediately", "resigned"],
    ["A message that makes the group chat quieter", "deadpan"],
    ["A message that makes it worse, efficiently", "low-effort-authority"],
    ["Answer like you’re tired of explaining", "tired-smart"],
    ["Answer like you’re doing someone a favor", "quietly-judgmental"],
    ["Reply like this is a recurring problem", "already-processed-this"],
    ["Give a yes that sounds like a no", "restrained"],
    ["Give a no that sounds like a yes", "neutral-but-pointed"],
    ["A compliment that feels like paperwork", "corporate-ghost"],
    ["A compliment that lands sideways", "dry"],
    ["Offer help in the most unhelpful way", "politely-detached"],
    ["Ask a question that feels accusatory (but isn’t)", "neutral-but-pointed"],
    ["Ask a question that feels like a trap", "calmly-ominous"],
    ["Narrate your own bad decision in real time", "matter-of-fact-chaos"],
    ["Provide an excuse that raises more questions", "post-context"],
    ["Send a message that implies you’re being monitored", "calmly-ominous"],
    ["Send a message like you’re the last adult in the room", "low-effort-authority"],
    ["Send a message like you’re not the adult in the room", "matter-of-fact-chaos"],
    ["A text that sounds like an ultimatum but isn’t", "minimalist-threat"],
    ["A text that is technically kind", "restrained"],
    ["A text that is technically accurate", "neutral-but-pointed"],
    ["A text that is technically a mistake", "matter-of-fact-chaos"],
    ["A text that implies you owe the universe money", "resigned"],
    ["A text that implies you’re owed an apology", "quietly-judgmental"],
    ["A text that quietly judges the entire situation", "faintly-disappointed"],
    ["A text that reads like a deleted scene", "post-context"],
    ["A text that reads like a footnote", "dry"],
    ["A text that reads like an incident report", "corporate-ghost"],
    ["A text that reads like a prophecy", "calmly-ominous"],
    ["A text that reads like a resignation (from reality)", "resigned"],
    ["A text that suggests you’ve accepted the consequences", "already-processed-this"],
    ["Work message sent from the wrong mental state", "corporate-ghost"],
    ["Corporate tone, personal exhaustion", "tired-smart"],
    ["Professional words, unclear intent", "neutral-but-pointed"],
    ["An update that sounds compliant but isn’t", "restrained"],
    ["A status update that feels ominous", "calmly-ominous"],
    ["A meeting excuse that HR would accept but hate", "quietly-judgmental"]
  ];

  const $ = (id) => document.getElementById(id);

  function setStatus(msg){ $("status").textContent = msg || ""; }
  function setMicStatus(msg){ $("micStatus").textContent = msg || "Mic: idle"; }
  function setMicNote(msg){ $("micNote").textContent = msg || ""; }

  function init(){
    // Fill scenario dropdown
    for (const [name] of SCENARIOS){
      const o = document.createElement("option");
      o.value = name;
      o.textContent = name;
      $("scenario").appendChild(o);
    }

    // Fill tone dropdown
    for (const t of TONES){
      const o = document.createElement("option");
      o.value = t;
      o.textContent = t;
      $("tone").appendChild(o);
    }

    // When scenario changes: auto-set tone, and only auto-fill prompt if prompt is empty
    $("scenario").onchange = () => {
      const found = SCENARIOS.find(s => s[0] === $("scenario").value);
      if (found) $("tone").value = found[1];
      setStatus("");
      if (!$("prompt").value.trim()) $("prompt").value = $("scenario").value;
    };

    // set initial
    $("scenario").selectedIndex = 0;
    $("scenario").dispatchEvent(new Event("change"));

    // mic support check
    if (!navigator.mediaDevices || !window.MediaRecorder) {
      $("mic").disabled = true;
      $("micStop").disabled = true;
      setMicStatus("Mic: unsupported");
      setMicNote("Browser can’t record audio here.");
    }
  }

  // -------- MIC RECORDING (voice -> multipart form-data) --------
  let mediaRecorder = null;
  let chunks = [];
  let micStream = null;

  async function startRecording(){
    setMicNote("");

    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch {
      setMicStatus("Mic: blocked");
      setMicNote("Mic permission denied.");
      return;
    }

    chunks = [];

    // Choose a safe mime type (prevents “corrupted/unsupported”)
    const candidates = [
      "audio/webm;codecs=opus",
      "audio/ogg;codecs=opus",
      "audio/webm",
      "audio/ogg"
    ];
    const mimeType =
      window.MediaRecorder &&
      candidates.find(t => MediaRecorder.isTypeSupported(t)) || "";

    try {
      mediaRecorder = new MediaRecorder(
        micStream,
        mimeType ? { mimeType } : undefined
      );
    } catch {
      setMicStatus("Mic: error");
      setMicNote("Recorder failed to start.");
      return;
    }

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) chunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      try {
        const type =
          mediaRecorder.mimeType ||
          (chunks[0] && chunks[0].type) ||
          "audio/webm";

        const blob = new Blob(chunks, { type });

        // Block empty / too-short recordings
        if (!blob.size || blob.size < 800) {
          setMicStatus("Mic: empty");
          setMicNote("Recording too short. Try again (2–3 seconds).");
          return;
        }

        await sendAudio(blob, type);
      } finally {
        try { micStream.getTracks().forEach(t => t.stop()); } catch {}
        micStream = null;
        mediaRecorder = null;
        chunks = [];
      }
    };

    mediaRecorder.start();
    $("mic").disabled = true;
    $("micStop").disabled = false;
    setMicStatus("Mic: recording…");
  }

  async function stopRecording(){
    if (!mediaRecorder) return;
    $("micStop").disabled = true;
    setMicStatus("Mic: processing…");
    try { mediaRecorder.stop(); } catch {}
    $("mic").disabled = false;
  }

  async function sendAudio(blob, type){
    const tone = $("tone").value;
    const details = $("details").value.trim();
    const scenarioPick = $("scenario").value;

    const ext = type.includes("ogg") ? "ogg" : "webm";

    const fd = new FormData();
    fd.append("audio", blob, `voice.${ext}`);
    fd.append("tone", tone);
    fd.append("details", details);
    fd.append("scenario", scenarioPick);

    $("output").textContent = "Transcribing…";

    const res = await fetch(WORKER_URL, {
      method: "POST",
      body: fd
    });

    const data = await res.json();
    const text = data?.text ? String(data.text).trim() : "";
    $("output").textContent = text || "No output.";

    setMicStatus("Mic: done");
    setMicNote("Voice sent.");
  }

  // -------- TEXT GENERATION (JSON) --------
  // Precedence:
  // 1) prompt box text (typed OR user-edited)
  // 2) scenario dropdown
  // 3) fallback
  function computeScenario(){
    const typed = $("prompt").value.trim();
    if (typed) return typed;

    const pick = $("scenario").value.trim();
    if (pick) return pick;

    return "Generate something strange";
  }

  async function callWorker(forceReroll){
    const scenario = computeScenario();
    const tone = $("tone").value;
    const details = $("details").value.trim();

    const payload = {
      scenario,
      tone,
      details,
      nonce: forceReroll ? (Date.now() + ":" + Math.random()) : undefined
    };

    $("output").textContent = "Thinking…";

    const res = await fetch(WORKER_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const data = await res.json();
    const text = data?.text ? String(data.text).trim() : "";
    $("output").textContent = text || "No output.";
  }

  // -------- BUTTON WIRING --------
  $("mic").onclick = async () => {
    try { await startRecording(); }
    catch { setMicStatus("Mic: error"); setMicNote("Recording failed."); }
  };

  $("micStop").onclick = async () => {
    try { await stopRecording(); }
    catch { setMicStatus("Mic: error"); setMicNote("Stop failed."); }
  };

  $("gen").onclick = async () => {
    try { await callWorker(false); setStatus(""); }
    catch { $("output").textContent = "Error calling AI."; setStatus("Worker call failed."); }
  };

  $("reroll").onclick = async () => {
    try { await callWorker(true); setStatus(""); }
    catch { $("output").textContent = "Error calling AI."; setStatus("Worker call failed."); }
  };

  $("copy").onclick = async () => {
    try {
      await navigator.clipboard.writeText($("output").textContent || "");
      setStatus("Copied.");
    } catch {
      setStatus("Copy failed.");
    }
  };

  init();
</script>

<!-- --- TypeRace (mini TypeRacer-style) --- -->
<style>
  .raceWrap{ margin-top:14px; border-radius:12px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.30); padding:12px; }
  .raceTop{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
  .raceStats{ font-size:12px; opacity:.75; display:flex; gap:12px; flex-wrap:wrap; }
  .raceText{ margin-top:10px; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.25); line-height:1.5; }
  .raceText span.ok{ opacity:1; text-decoration:underline; }
  .raceText span.bad{ opacity:1; text-decoration:underline; }
  .raceText span.todo{ opacity:.55; }
  .raceBar{ height:10px; border-radius:999px; border:1px solid rgba(255,255,255,0.10); background:rgba(255,255,255,0.05); overflow:hidden; margin-top:10px; }
  .raceBar > div{ height:100%; width:0%; background:rgba(255,255,255,0.18); }
</style>

<div class="raceWrap" id="raceWrap">
  <div class="raceTop">
    <div style="font-size:12px;opacity:.85;">TypeRace</div>
    <div class="btns" style="margin:0;">
      <button id="raceNew">New text</button>
      <button class="primary" id="raceStart">Start</button>
      <button id="raceReset">Reset</button>
    </div>
  </div>

  <div class="raceStats">
    <span id="raceTime">Time: 0.0s</span>
    <span id="raceWpm">WPM: 0</span>
    <span id="raceAcc">Acc: 100%</span>
    <span id="raceBest">Best: –</span>
  </div>

  <div class="raceText" id="raceText"></div>
  <div class="raceBar"><div id="raceFill"></div></div>

  <label style="margin-top:10px;">Type here</label>
  <textarea id="raceInput" placeholder="Start typing…" style="min-height:70px;"></textarea>
  <div class="tiny" id="raceHint">Press Start, then type. Timer begins on first keystroke.</div>
</div>

<script>
(() => {
  const texts = [
    "Systems behave perfectly until humans decide to test them.",
    "A clean interface is a lie told politely to chaos.",
    "Stability is not calm. It is maintenance done on time.",
    "Type fast, think faster, and do not trust the first draft.",
    "The machine is consistent. The operator is the variable.",
    "Speed is a skill. Accuracy is a choice. Pick both."
  ];

  const $ = (id) => document.getElementById(id);

  const state = {
    target: "",
    started: false,
    startAt: 0,
    raf: 0,
    done: false,
    best: Number(localStorage.getItem("swn_typerace_best") || "0")
  };

  function pickText(){
    state.target = texts[Math.floor(Math.random() * texts.length)];
    renderText("");
    $("raceInput").value = "";
    $("raceFill").style.width = "0%";
    $("raceTime").textContent = "Time: 0.0s";
    $("raceWpm").textContent = "WPM: 0";
    $("raceAcc").textContent = "Acc: 100%";
    $("raceHint").textContent = "Press Start, then type. Timer begins on first keystroke.";
    state.started = false;
    state.done = false;
    cancelAnimationFrame(state.raf);
  }

  function renderText(typed){
    const t = state.target;
    let html = "";
    for (let i = 0; i < t.length; i++){
      const ch = t[i];
      const u = typed[i];
      if (u === undefined) html += `<span class="todo">${escapeHtml(ch)}</span>`;
      else if (u === ch) html += `<span class="ok">${escapeHtml(ch)}</span>`;
      else html += `<span class="bad">${escapeHtml(ch)}</span>`;
    }
    $("raceText").innerHTML = html;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }

  function metrics(typed, elapsedSec){
    const t = state.target;

    // accuracy over typed chars
    let correct = 0;
    for (let i = 0; i < typed.length; i++) if (typed[i] === t[i]) correct++;
    const acc = typed.length ? (correct / typed.length) : 1;

    // WPM: (chars/5)/minutes
    const minutes = Math.max(elapsedSec / 60, 1/6000);
    const wpm = Math.max(0, Math.round((correct / 5) / minutes));

    const progress = Math.min(1, typed.length / t.length);

    return { acc, wpm, progress, correct };
  }

  function tick(){
    if (!state.started || state.done) return;
    const now = performance.now();
    const elapsed = (now - state.startAt) / 1000;
    $("raceTime").textContent = `Time: ${elapsed.toFixed(1)}s`;

    const typed = $("raceInput").value;
    const { acc, wpm, progress } = metrics(typed, elapsed);

    $("raceWpm").textContent = `WPM: ${wpm}`;
    $("raceAcc").textContent = `Acc: ${Math.round(acc * 100)}%`;
    $("raceFill").style.width = `${Math.round(progress * 100)}%`;

    state.raf = requestAnimationFrame(tick);
  }

  function start(){
    $("raceInput").focus();
    $("raceHint").textContent = "Typing…";
  }

  function reset(){
    pickText();
    updateBest();
  }

  function updateBest(){
    $("raceBest").textContent = state.best ? `Best: ${state.best} WPM` : "Best: –";
  }

  // events
  $("raceNew").onclick = pickText;
  $("raceStart").onclick = start;
  $("raceReset").onclick = reset;

  $("raceInput").addEventListener("input", () => {
    const typed = $("raceInput").value;

    if (!state.started && typed.length){
      state.started = true;
      state.startAt = performance.now();
      cancelAnimationFrame(state.raf);
      state.raf = requestAnimationFrame(tick);
    }

    renderText(typed);

    const elapsed = state.started ? (performance.now() - state.startAt) / 1000 : 0.0001;
    const { wpm, progress } = metrics(typed, elapsed);
    $("raceFill").style.width = `${Math.round(progress * 100)}%`;

    if (!state.done && typed === state.target){
      state.done = true;
      cancelAnimationFrame(state.raf);
      $("raceHint").textContent = "Finished.";

      if (wpm > state.best){
        state.best = wpm;
        localStorage.setItem("swn_typerace_best", String(wpm));
        updateBest();
      }
    }
  });

  // init
  pickText();
  updateBest();
})();
</script>

</body>
</html>
